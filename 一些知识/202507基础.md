# HTML
  ## 盒模型
    1. 两种和盒模型
      答：标准盒模型和IE盒模型
        - 标准盒模型：width和height只包含内容区域，不包括padding、border和margin
        - IE盒模型：width和height包含内容、padding和border，但不包括margin
    2. 盒模型的组成部分（内容、内边距、边框、外边距）
      答：
        - 内容：实际显示的内容区域
        - 内边距：内容与边框之间的空间
        - 边框：包裹内容和内边距的边框
        - 外边距：元素与其他元素之间的空间
    3. 盒模型的计算方式（标准盒模型和IE盒模型）
      答：
        - 标准盒模型：width = content + padding + border
        - IE盒模型：width = content + padding + border + margin
  ## 语义化标签
    1. 对语义化标签的理解
      答：语义化标签是指那些具有明确含义的HTML标签，它们不仅描述了内容的结构，还提供了关于内容的额外信息，有助于搜索引擎和辅助技术理解页面内容。
    2. 常见的语义化标签（如：header、footer、article、section等）
      答：
        - header：定义文档的头部区域，通常包含导航链接和标题
        - footer：定义文档的底部区域，通常包含版权信息和联系信息
        - article：定义独立的内容块，如文章或博客帖子
        - section：定义文档中的一个章节或部分

  ## 对W3C的理解和认识
    1. W3C的全称和作用
      答：W3C（World Wide Web Consortium）是万维网联盟，负责制定Web标准和指导方针，以确保Web的长期发展和互操作性。
    2. W3C标准的重要性
      答：W3C标准确保了Web内容在不同浏览器和设备上的一致性和可访问性，有助于提高用户体验和Web的可用性。

  ## 说说SEO
    1. SEO的概念 TDK是什么
      答：SEO（Search Engine Optimization）是指通过优化网站结构、内容和外部链接等方式，提高网站在搜索引擎结果中的排名，从而增加网站的可见性和访问量。
      TDK是指标题（Title）、描述（Description）和关键词（Keywords），是SEO优化的重要组成部分。
    2. SEO的优化方式（内部优化、外部优化）
      答：
        - 内部优化：包括网站结构优化、内容优化、关键词布局、页面加载速度等
        - 外部优化：包括外部链接建设、社交媒体推广、品牌曝光等
  ## iframe
    1. iframe的概念
      答：iframe（内联框架）是HTML中的一个元素，用于在当前页面中嵌入另一个HTML页面。它允许在一个页面中显示来自其他来源的内容。
    2. iframe的优缺点
      答：
        - 优点：可以嵌入外部内容，支持跨域加载，便于内容更新和维护
        - 缺点：可能影响页面加载速度，存在安全性问题（如XSS攻击），对SEO不友好
  ## 微格式
    1. 微格式的概念
      答：微格式是一种在HTML中嵌入结构化数据的方式，通过使用特定的类名和属性，使得搜索引擎和其他应用程序能够更好地理解页面内容的含义。
    2. 微格式的作用
      答：微格式可以帮助搜索引擎更好地解析和索引页面内容，提高搜索结果的相关性和可见性，同时也有助于改善用户体验。
  ## 替换元素
    1. 替换元素的概念
      答：替换元素是指那些在渲染时会被浏览器替换为其他内容的HTML元素，如图片、输入框等。这些元素的实际显示内容由浏览器决定，而不是由CSS样式控制。
    2. 替换元素的特点
      答：替换元素通常具有固定的宽度和高度，浏览器会根据其内容类型（如图片、视频等）来渲染它们。它们的样式属性（如margin、padding等）可能会受到限制。
    3. 常见的替换元素（如：img、input、textarea等）
      答：常见的替换元素包括：
        - img：用于显示图片
        - input：用于用户输入
        - textarea：用于多行文本输入
    4. 替换元素与非替换元素的区别
      答：替换元素的内容由浏览器决定，而非替换元素的内容由CSS样式控制。替换元素通常具有固定的尺寸，而非替换元素的尺寸可以通过CSS调整。
  ## 页面可见性API
    1. 页面可见性的概念
      答：页面可见性API是一种用于检测和响应页面可见性变化的API，它可以帮助开发者了解页面何时在用户视口中可见，何时被隐藏。
    2. 页面可见性的影响因素
      答：影响页面可见性的因素包括浏览器窗口的大小、页面的滚动位置、其他元素的遮挡等。
    3. 页面可见性的应用场景
      答：页面可见性API可以用于实现懒加载、广告展示、视频播放等功能，以提高用户体验和页面性能。

# CSS
  ## CSS中有那些单位
    1. CSS中常见的单位
      答：CSS中常见的单位包括：
        - px（像素）：绝对单位，表示屏幕上的一个点
        - em：相对单位，基于父元素的字体大小
        - rem：相对单位，基于根元素（html）的字体大小
        - %（百分比）：相对单位，基于父元素的尺寸
        - vw（视口宽度）：相对于视口宽度的百分比
        - vh（视口高度）：相对于视口高度的百分比
        - vmin/vmax：相对于视口最小/最大尺寸的百分比

  ## 居中方式有那些
    1. 水平居中方式
      答：水平居中的方式包括：
        - 使用margin: auto；（适用于块级元素）
        - 使用text-align: center；（适用于行内元素或行内块元素）
        - 使用flexbox布局（设置父元素为display: flex; justify-content: center;）
        - 使用grid布局（设置父元素为display: grid; place-items: center;）

    2. 垂直居中方式
      答：垂直居中的方式包括：
        -  vertical-align: middle;（适用于行内元素或行内块元素）
        - 使用line-height与元素高度相等（适用于 单行文本）
        - 使用flexbox布局（设置父元素为display: flex; align-items: center;）
        - 使用grid布局（设置父元素为display: grid; place-items: center;）
        - 使用绝对定位（设置top、bottom、left、right为0，并使用margin:auto;）
        - 使用transform（设置transform: translateY(-50%);，并设置top为50%）

  ## 隐藏元素
    1. 隐藏元素的方式
      答：隐藏元素的方式包括：
        - H5新增的hidden属性（如：<div hidden></div>）
        - display:  none;（完全移除元素，不占据空间）
        - visibility: hidden;（隐藏元素，但仍占据空间）
        - opacity: 0;（使元素透明，但仍占据空间）
        - position: absolute; left: -9999px;（将元素移出视口）
        - 使用CSS类切换来控制显示和隐藏

    2. 隐藏元素的优缺点
      答：
        - display: none; 优点：完全移除元素，缺点：无法通过CSS样式访问
        - visibility: hidden; 优点：保留空间，缺点：仍然不可见
        - opacity: 0; 优点：可以通过CSS样式访问，缺点：仍然占据空间
        - position: absolute; left: -9999px; 优点：可以通过CSS样式访问，缺点：仍然占据空间
  ## 浮动
    1. 浮动的特性
      答：浮动是CSS中的一种布局方式，通过将元素设置为float属性，可以使元素脱离正常的文档流，并向左或向右浮动。浮动元素会影响其后续元素的布局。
        - 脱离文档流
        - 变成行内块元素
        - 影响后续元素的布局
    2. 浮动的应用场景
      答：
        - 文字环绕图片：通过将图片设置为浮动，可以实现文字环绕在图片周围的效果。
        - 多列布局：使用浮动可以创建多列布局，使元素并排显示。
        - 自适应布局：结合媒体查询和浮动，可以实现响应式布局。
    3. 浮动的缺点
      答：
        - 浮动元素可能会导致父元素高度塌陷，需要使用clearfix等方法清除浮动。
        - 浮动元素的布局可能会受到其他元素的影响，导致意外的布局问题。
        - 浮动元素在某些情况下可能会导致浏览器渲染性能下降。
    4. 清除浮动的方法
      答：清除浮动的方法包括：
        - 给父元素设置高度（要大于浮动子元素的高度）
        - 使用clearfix类：在父元素上添加一个clearfix类，通过伪元素::after清除浮动。
        - 使用overflow属性：设置父元素的overflow属性为hidden或auto，可以清除浮动。
        - 使用空元素：在浮动元 素后添加一个空的div，并设置clear: both;（会让margin和padding失效）
        - 使用CSS Flexbox或Grid布局替代浮动布局。
  ## 定位
    1. 定位的概念
      答：定位是CSS中的一种布局方式，通过设置元素的position属性，可以控制元素在页面中的位置。常见的定位方式包括静态定位、相对定位、绝对定位、固定定位和粘性定位。
    2. 定位的类型
      答：
        - 静态定位（static）：默认定位方式，元素按照文档流正常排列，不受top、right、bottom、left属性影响。
        - 相对定位（relative）：相对于元素自身的原始位置进行偏移，可以使用top、right、bottom、left属性进行调整。
        - 绝对定位（absolute）：相对于最近的已定位祖先元素进行定位，如果没有已定位祖先，则相对于初始包含块（通常是html或body）。
        - 固定定位（fixed）：相对于浏览器窗口进行定位，元素在页面滚动时保持在固定位置。
        - 粘性定位（sticky）：结合了相对定位和固定定位，当元素在视口中滚动到指定位置时，会变为固定定位。
    3. 定位的应用场景
      答：
        - 相对定位：用于微调元素位置，常用于创建悬停效果或工具提示。
        - 绝对定位：用于创建弹出菜单、模态框等，需要脱离文档流的元素。
        - 固定定位：用于创建固定在视口中的导航栏、页脚等。
        - 粘性定位：用于创建在滚动时保持在视口中的元素，如粘性导航栏。
    4. 定位的优缺点
      答：
        - 相对定位：优点是可以微调元素位置，缺点是仍然占据文档流空间。
        - 绝对定位：优点是可以脱离文档流，灵活控制位置，缺点是可能导致布局问题，需要清除浮动，盒子会变成block元素。
        - 固定定位：优点是元素在视口中保持固定位置，缺点是可能影响页面滚动体验。
        - 粘性定位：优点是结合了相对和固定定位的优点，缺点是浏览器兼容性较差。
  ## BFC
    1. BFC的概念
      答：BFC（Block Formatting Context）是CSS中的一个布局概念，它是一个独立的渲染区域，元素在BFC中按照块级格式化规则进行布局。BFC可以防止外边距合并、清除浮动等问题。
    2. BFC的触发条件
      答：触发BFC的条件包括：
        - 根元素（html、body）
        - 浮动元素（float不为none）
        - 绝对定位元素（position为absolute或fixed）
        - inline-block元素（display为inline-block）
        - overflow属性不为visible（如：overflow: hidden;）
        - display属性为flex或grid
    3. BFC的作用
      答：
        - 防止外边距合并：BFC内的元素不会与外部元素的外边距合并。
        - 清除浮动：BFC可以包含浮动元素，避免父元素高度塌陷。
        - 控制布局：BFC可以控制元素的布局和定位，使其独立于其他元素。
    4. BFC的应用场景
      答：
        - 创建独立的布局区域，如弹出菜单、模态框等。
        - 清除浮动，避免父元素高度塌陷。
        - 控制外边距，避免外边距合并导致布局问题。
    5. BFC的规则
      答：
        - BFC内的元素不会与外部元素的外边距合并。
        - BFC内的元素按照块级格式化规则进行布局。
        - BFC内的元素可以包含浮动元素，避免父元素高度塌陷。
        - BFC内的元素不会影响外部元素的布局。
    6. BFC、IFC、GFC、FFC的区别
      答：
        - BFC（Block Formatting Context）：块级格式化上下文，主要用于控制块级元素的布局和外边距合并。
        - IFC（Inline Formatting Context）：行内格式化上下文，主要用于控制行内元素的布局和换行。
        - GFC（Grid Formatting Context）：网格格式化上下文，主要用于CSS Grid布局。
        - FFC（Flex Formatting Context）：弹性格式化上下文，主要用于CSS Flexbox布局。
  ## CSS属性的计算过程
    1. CSS属性的计算过程
      答：CSS属性的计算过程包括以下几个步骤：
        - 解析：浏览器解析CSS规则，将其转换为内部表示形式。
        - 计算：浏览器根据元素的样式和布局规则计算每个元素的最终样式值。
        - 应用：将计算后的样式应用到元素上，渲染页面。
    2. CSS属性的优先级
      答：CSS属性的优先级由以下几个因素决定：
        - 内联样式（最高优先级） 1000
        - ID选择器 100
        - 类选择器、属性选择器和伪类选择器 10
        - 元素选择器和伪元素选择器 1
        - 通配符选择器 '*'（最低优先级） * 0
    3. CSS属性的继承
      答：CSS属性的继承是指某些样式属性会从父元素继承到子元素，如字体、颜色等。非继承属性（如margin、padding等）不会被继承。
    4. CSS属性的计算顺序
      答：确定声明值->层叠冲突->使用继承->使用默认
  ## CSS属性的层叠继承规则
    答：重要性 > 专用性 > 源代码次序
      - 层叠顺序：后定义的样式优先级更高。
      - 继承规则：可继承属性从父元素继承，非继承属性使用（就近原则）。
      - 优先级：内联样式 > ID选择器 > 类选择器 > 元素选择器 > 通配符选择器。
      - 重要性：使用!important标记的样式优先级最高。
  ## 引入CSS
    1. 引入CSS的方式
      答：引入CSS的方式包括：
        - 内联样式\嵌入（style属性）：直接在HTML元素中使用style属性定义样式。
        - 内部样式表\内联（<style>标签）：在HTML文档的<head>部分使用<style>标签定义样式。
        - 外部样式表\外联（<link>标签）：使用<link>标签链接外部CSS文件。
        - @import规则：在CSS文件或者<style>中使用@import语句导入其他CSS文件。
    2. 引入CSS的优缺点
      答：
        - 内联样式：优点是快速应用样式，缺点是难以维护和复用。
        - 内部样式表：优点是可以集中管理样式，缺点是无法在多个页面复用。
        - 外部样式表：优点是易于维护和复用，缺点是需要额外的HTTP请求加载CSS文件。
        - @import规则：支持媒体查询，优点是可以按需加载样式，缺点是加载顺序可能影响样式应用，且会增加HTTP请求。
        - JS控制DOM只能使用link，无法使用@import
        - 性能优化来看避免使用@import，因为会增加额外的HTTP请求和加载时间。
  ## calc
    1. calc的概念
      答：calc()是CSS中的一个函数，用于在样式中进行动态计算，可以结合不同的单位进行数学运算，如加法、减法、乘法和除法。
    2. calc的使用场景
      答：calc()常用于需要动态计算尺寸、位置或其他样式属性的场景，如响应式布局、复杂的定位等。
    3. calc的语法
      答：calc()的基本语法为：calc(expression)，其中expression可以是数字、单位和运算符（如+、-、*、/）。
    4. calc的注意事项
      答：
        - 运算符两边必须有空格。
        - 不支持混合使用百分比和绝对单位（如px）。
        - 在某些情况下，可能会影响性能，需谨慎使用。
  ## 媒体查询 media
    1. 媒体查询的概念
      答：媒体查询是CSS中的一种技术，用于根据设备的特性（如屏幕宽度、高度、分辨率等）应用不同的样式。它使得响应式设计成为可能。
    2. 媒体查询的语法
      答：媒体查询的基本语法为：
        ```css
        @media media-type and (condition) {
          /* CSS规则 */
        }
        @media screen and (min-width: 600px) {
          body {
            background-color: lightblue;
          }
        }
        ```
        其中，media-type可以是all、screen、print等（默认是all，media-type and 可以不写），condition可以是min-width、max-width等，可以用and连接多个条件。
    3. 媒体查询的使用场景
      答：媒体查询常用于响应式设计，根据不同设备的屏幕尺寸和特性应用不同的样式，以提高用户体验。
    4. 媒体查询的优缺点
      答：
        - 优点：可以针对不同设备应用不同样式，提高用户体验和可访问性。
        - 缺点：可能增加CSS文件大小，影响加载性能，需要谨慎使用。
  ## 过度和动画
    1. 过渡的概念
      答：过渡是CSS中的一种效果，用于在元素的样式变化时创建平滑的动画效果。通过定义transition属性，可以指定过渡的属性、持续时间、延迟等。
    2. 过渡的语法
      答：过渡的基本语法为：
        ```css
        transition: property duration timing-function delay;
        ```
        其中，property是要过渡的CSS属性，duration是过渡持续时间，timing-function是过渡曲线（如ease、linear等），delay是延迟时间。
    3. 过渡事件
      答：过渡事件是指在过渡效果开始、结束或中断时触发的事件，如transitionstart、transitionend和transitioncancel。这些事件可以用于执行特定的JavaScript代码，以响应过渡效果。

    4. 动画的概念
      答：动画是CSS中的一种效果，用于创建复杂的动画效果，可以通过@keyframes规则定义动画帧，并使用animation属性应用到元素上。
    5. 动画的语法
      答：动画的基本语法为：
        ```css
        @keyframes animation-name {
          from { /* 初始状态 */ }
          to { /* 结束状态 */ }
        }
        @keyframes animation-name {
          0% { /* 初始状态 */ }
          100% { /* 结束状态 */ }
        }
        div{
          animation: animation-name duration timing-function delay iteration-count direction fill-mode;
          animation-play-state: paused; /* 暂停动画 running 启动 */
          animation-fill-mode: forwards; /* 保持动画结束状态 */
        }
        ```
        其中，animation-name是动画名称，duration是动画持续时间，timing-function是动画曲线，delay是延迟时间，iteration-count是迭代次数，direction是方向（如normal、reverse等），fill-mode是填充模式（如forwards、backwards等）。
    6. 动画事件
      答：动画事件是指在动画效果开始、结束或中断时触发的事件，如animationstart、animationend和animationcancel。这些事件可以用于执行特定的JavaScript代码，以响应动画效果。
    7. 过渡和动画的区别
      答：
        - 过渡：用于在元素样式变化时创建平滑的动画效果，通常用于简单的样式变化，如颜色、位置等。
        - 动画：用于创建复杂的动画效果，可以定义多个关键帧，支持更丰富的动画效果和控制。
        - 过渡是单一属性变化的平滑过渡，而动画可以包含多个属性变化和关键帧。
  ## 渐进增强和优雅降级
    1. 渐进增强的概念
      答：渐进增强是一种Web开发策略，首先构建一个基本的、功能完整的Web应用，然后逐步添加高级功能和样式，以确保在不同浏览器和设备上都能正常工作。
    2. 优雅降级的概念
      答：优雅降级是一种Web开发策略，首先构建一个功能丰富的Web应用，然后确保在较旧或不支持新技术的浏览器中仍能提供基本功能和可用性。
    3. 渐进增强和优雅降级的区别
      答：渐进增强强调从基础开始构建，逐步添加功能，而优雅降级强调从完整功能开始，确保在较旧浏览器中仍能提供基本体验。渐进增强更注重可访问性和兼容性，而优雅降级更注重用户体验。
    4. 写法的不同
      答：渐进增强通常使用HTML5和CSS3等新技术，确保基本功能在所有浏览器中可用，然后添加JavaScript增强功能。而优雅降级则从完整的功能开始，使用JavaScript和CSS来提供更丰富的体验，同时确保在较旧浏览器中仍能正常工作。
  ## CSS3变形
    1. CSS3变形的概念
      答：CSS3变形是指使用transform属性对元素进行旋转、缩放、倾斜和平移等变形操作。它可以创建丰富的视觉效果和动画。
    2. CSS3变形的语法
      答：CSS3变形的基本语法为：
        ```css
        transform: transform-function;
        ```
        其中，transform-function可以是rotate、scale、skew、translate等。
    3. CSS3变形的应用场景
      答：CSS3变形常用于创建动画效果、交互效果和视觉效果，如旋转按钮、缩放图片、倾斜文本等。
    4. CSS3变形的注意事项
      答：
        - 变形会影响元素的布局和定位，需要谨慎使用。
        - 在某些情况下，可能会影响浏览器渲染性能，需优化使用。
        - 需要考虑浏览器兼容性，确保在不同浏览器中正常工作。
    5. CSS3变形的兼容性
      答：CSS3变形在现代浏览器中得到广泛支持，但在较旧的浏览器中可能不完全支持。开发者可以使用前缀（如-webkit-、-moz-等）来提高兼容性，同时使用特性检测（如Modernizr）来判断浏览器是否支持特定的变形功能。
  ## 渐进式渲染
    1. 渐进式渲染的概念
      答：渐进式渲染是一种Web开发策略，通过逐步加载和渲染页面内容，提高页面加载速度和用户体验。它可以在页面加载时先显示基本内容，然后逐步加载和渲染其他资源。
    2. 渐进式渲染的实现方式
      答：渐进式渲染可以通过以下方式实现：
        - 骨架屏技术，先显示页面的骨架结构，然后加载实际内容。
        - 使用懒加载技术，延迟加载非关键资源（如图片、视频等）。
        - 使用异步加载JavaScript和CSS文件，避免阻塞页面渲染。
        - 优化资源大小和格式，减少HTTP请求和加载时间。
        - 使用服务器端渲染（SSR）或静态站点生成（SSG）来提高初始加载速度。
    3. 渐进式渲染的优点
      答：
        - 提高页面加载速度，减少用户等待时间。
        - 改善用户体验，使用户能够更快地访问和交互页面内容。
        - 减少服务器负载，提高性能和可扩展性。
  ## CSS渲染性能优化
    1. id选择器性能更好
    2. 避免深层次的选择器
    3. 不用属性选择器
    4. 浏览器前缀前置
    5. 用缩写、0不写单位
    6. css优先于js
    7. csslint
    8. 不用@import
    9. 避免过分重排
  ## 重排和重绘
    1. 重排的概念
      答：重排（Reflow）是指浏览器重新计算元素的几何属性（如位置、大小等），通常发生在元素的尺寸、位置或内容发生变化时。
    2. 重绘的概念
      答：重绘（Repaint）是指浏览器重新渲染元素的外观，但不涉及几何属性的变化。通常发生在元素的颜色、背景等样式发生变化时。
    3. 重排和重绘的区别
      答：重排会导致浏览器重新计算元素的位置和大小，而重绘只会重新渲染元素的外观。重排比重绘更耗费性能，因为它涉及到布局计算。
    4. 重排和重绘的优化方法
      答：
        - 减少DOM操作，批量修改DOM以减少重排次数。
        - 使用CSS类切换而不是直接修改样式，以减少重排。
        - 使用文档片段（DocumentFragment）进行批量插入，避免多次重排。
        - 避免频繁读取布局属性（如offsetWidth、clientHeight等），因为这会触发浏览器强制重排。
        - 使用CSS3变形和过渡来实现动画效果，减少对布局的影响。
    5. 重排和重绘的性能影响
      答：重排和重绘会影响浏览器的渲染性能，频繁的重排和重绘会导致页面卡顿和响应迟钝。优化重排和重绘可以提高页面性能和用户体验。
    6. 重排和重绘的触发条件
      答：重排通常在以下情况下触发：
        - 元素的尺寸或位置发生变化（如添加、删除、修改元素）。
        - 页面结构发生变化（如插入或删除节点）。
        - CSS样式发生变化（如修改宽度、高度、边距等）。
      重绘通常在以下情况下触发：
        - 元素的颜色、背景、字体等样式发生变化。
        - 元素的可见性发生变化（如显示或隐藏元素）。
        - 元素的内容发生变化，但不影响其几何属性。
  ## 层叠上下文
    1. 层叠上下文的概念
      答：层叠上下文（Stacking Context）是CSS中的一个概念，用于控制元素在三维空间中的堆叠顺序。每个层叠上下文都是一个独立的渲染层，元素在该层内按照特定规则进行堆叠。
    2. 层叠上下文的触发条件
      答：触发层叠上下文的条件包括：
        - 根元素（html、body）
        - 绝对定位元素（positi330+=110935on为absolute或fixed，z-index不为auto）
        - 相对定位元素（position为relative，z-index不为auto）
        - flex容器（display为flex或inline-flex，z-index不为auto）
        - grid容器（display为grid或inline-grid，z-index不为auto）
        - opacity小于1
        - transform属性应用了非none值
    3. 层叠上下文的作用
      答：层叠上下文可以控制元素在堆叠顺序中的位置，使得某些元素可以覆盖其他元素。它有助于解决复杂的布局问题，如模态框、弹出菜单等。
    4. 层叠上下文的应用场景
      答：层叠上下文常用于创建复杂的布局和交互效果，如模态框、工具提示、下拉菜单等，以确保这些元素在视觉上正确地覆盖其他内容。
  ## CSS3 遮罩
    答：CSS3 遮罩（Mask）是一种用于控制元素可见区域的技术，可以实现复杂的形状和透明效果。通过使用遮罩，可以隐藏元素的部分区域，显示出底层内容或背景。
    1. 常见属性
      ```css
      mask: mask-image;
      mask-mode: alpha;
      mask-repeat: no-repeat;
      mask-position: center;
      mask-size: cover;
      mask-clip: content-box;
      mask-origin: content-box;
      mask-composite: add;
      ```
# JavaScript
  ## 作用域
      1. 作用域的概念
        答：作用域是指变量、函数等标识符的可访问范围。JavaScript中有全局作用域和局部作用域。
      2. 全局作用域和局部作用域
        答：
          - 全局作用域：在整个脚本中都可访问的变量和函数。
          - 函数作用域：函数内部的作用域，函数外部无法访问。
          - 块级作用域：使用let、const等关键字定义的变量，只在块级作用域内有效。
      3. 闭包的概念
        答：闭包是指一个函数可以访问其外部函数的变量，即使外部函数已经执行完毕。闭包可以用于数据封装和私有变量。
      4. 闭包的应用场景
        答：闭包常用于创建私有变量、模拟私有方法、实现模块化编程等。
      5. 闭包的优缺点
        答：
          - 优点：可以封装数据，避免全局污染，提供更好的代码组织。
          - 缺点：可能导致内存泄漏，过度使用会影响性能。
      6. 闭包的实现方式
        答：闭包可以通过以下方式实现：
          - 在函数内部定义函数，并将其作为返回值返回。
          - 使用立即执行函数表达式（IIFE）创建私有作用域。
          - 利用块级作用域（如let、const）创建闭包。
  ## let、var、const
    1. let、var、const的区别
      答：
        - var：函数作用域或全局作用域，可以重复声明，提升到函数或全局顶部。
        - let：块级作用域，不能重复声明，不提升。
        - const：块级作用域，不能重复声明，必须初始化，值不可变（但对象属性可变）。
    2. let、var、const的使用场景
      答：
        - var：适用于需要函数作用域的变量，但不推荐使用。
        - let：适用于需要块级作用域的变量，如循环计数器等。
        - const：适用于需要常量值的变量，如配置项等。
    3. let、var、const的提升
      答：
        - var会提升到函数或全局顶部，可以在声明之前使用，但值为undefined。
        - let和const不会提升，必须在声明之后使用，否则会抛出错误。
    4. let、var、const的作用域
      答：
        - var的作用域是函数作用域或全局作用域。
        - let和const的作用域是块级作用域，即在花括号内有效。
  ## JS的数据类型
    答：JavaScript中的数据类型分为两类：基本数据类型和引用数据类型。
    1. 基本数据类型
      答：基本数据类型包括：
        - Number：数字类型，表示整数或浮点数。
        - String：字符串类型，用于表示文本。
        - Boolean：布尔类型，表示真（true）或假（false）。
        - Undefined：未定义类型，表示变量未赋值。
        - Null：空类型，表示无值。
        - Symbol：符号类型，用于创建唯一的标识符（ES6引入）。
        - BigInt：大整数类型，用于表示大于2^53-1的整数（ES11引入）。
    2. 引用数据类型
      答：引用数据类型包括：
        - Object：对象类型，用于存储键值对。
        - Array：数组类型，特殊的对象，用于存储有序的元素集合。
        - Function：函数类型，特殊的对象，用于定义可执行的代码块。
        - Date：日期类型，用于处理日期和时间。
        - RegExp：正则表达式类型，用于模式匹配和文本处理。
    3. 数据类型的判断
      答：可以使用typeof运算符判断基本数据类型，使用instanceof运算符判断引用数据类型。
        - typeof：返回值为字符串，表示变量的数据类型，如typeof 123 返回 "number"。
        - instanceof：用于判断对象是否是某个构造函数的实例，如[] instanceof Array 返回 true。
        - Object.prototype.toString.call()：可以更准确地判断数据类型，如Object.prototype.toString.call([]) 返回 "[object Array]"。
        - Array.isArray()：用于判断一个对象是否是数组，如Array.isArray([]) 返回 true。
        - Number.isNaN()：用于判断一个值是否是NaN（非数字），如Number.isNaN(NaN) 返回 true。
  ## JS的类型转换
    答：JavaScript中的类型转换分为隐式转换和显式转换。
    1. 隐式转换
      答：隐式转换是指JavaScript在需要时自动将一种数据类型转换为另一种数据类型，如字符串与数字的相加。
        - 字符串与数字相加时，数字会被转换为字符串。
        - 布尔值与其他类型进行运算时，布尔值会被转换为数字（true为1，false为0）。
        - 对象与基本类型进行运算时，对象会被转换为原始值。
    2. 显式转换
      答：显式转换是指开发者主动将一种数据类型转换为另一种数据类型，常见的显式转换方法包括：
        - String()：将其他类型转换为字符串，如String(123) 返回 "123"。
        - Number()：将其他类型转换为数字，如Number("123") 返回 123。
        - Boolean()：将其他类型转换为布尔值，如Boolean(0) 返回 false。
        - parseInt()：将字符串转换为整数，如parseInt("123px") 返回 123。
        - parseFloat()：将字符串转换为浮点数，如parseFloat("123.45px") 返回 123.45。
        - JSON.parse()：将JSON字符串转换为JavaScript对象，如JSON.parse('{"name":"John"}') 返回 {name: "John"}。
        - JSON.stringify()：将JavaScript对象转换为JSON字符串，如JSON.stringify({name: "John"}) 返回 '{"name":"John"}'。
    3. 类型转换的注意事项
      答：
        - 在进行隐式转换时，可能会导致意想不到的结果，如字符串与数字相加时，数字会被转换为字符串。
        - 在进行显式转换时，需要确保转换的值是有效的，否则可能会导致错误或NaN。
        - 使用严格等于（===）和不等于（!==）运算符可以避免隐式类型转换带来的问题。
        - 注意NaN的特殊性，NaN与任何值比较都返回false，包括自身。

  ## JS的包装类型
    答：JavaScript中的包装类型是指将基本数据类型包装为对象，以便提供更多的方法和属性。常见的包装类型包括：
    1. Number对象
      答：Number对象用于包装数字类型，提供了许多方法，如toFixed()、toExponential()等。
    2. String对象
      答：String对象用于包装字符串类型，提供了许多方法，如charAt()、substring()、toUpperCase()等。
    3. Boolean对象
      答：Boolean对象用于包装布尔类型，提供了toString()方法。
    4. Symbol对象
      答：Symbol对象用于创建唯一的标识符，不能被直接转换为字符串或数字。
    5. BigInt对象
      答：BigInt对象用于表示大整数，可以通过BigInt()函数创建。
    6. 包装类型的使用场景
      答：包装类型常用于需要调用基本数据类型的方法时，如字符串操作、数字格式化等。但在大多数情况下，直接使用基本数据类型更为高效。
    注意：自动装箱和拆箱，自动装箱的包装对象会在需要时自动创建，而拆箱则是将包装对象转换回基本数据类型，不会影响下面代码中的基本数据类型。
  ## JS的运算符
    答：JavaScript中的运算符分为以下几类：
    1. 算术运算符
      答：用于进行数学运算，如加法（+）、减法（-）、乘法（*）、除法（/）、取余（%）等。
    2. 比较运算符
      答：用于比较两个值，如等于（==）、不等于（!=）、严格等于（===）、严格不等于（!==）、大于（>）、小于（<）、大于等于（>=）、小于等于（<=）等。
    3. 逻辑运算符
      答：用于进行逻辑运算，如与（&&）、或（||）、非（!）等。
    4. 位运算符
      答：用于对整数的二进制位进行操作，如按位与（&）、按位或（|）、按位异或（^）、左移（<<）、右移（>>）和无符号右移（>>>）等。
    5. 赋值运算符
      答：用于给变量赋值，如赋值（=）、加赋值（+=）、减赋值（-=）、乘赋值（*=）、除赋值 (/=)、取余赋值 (%=) 等。
    6. 条件（三元）运算符
      答：用于根据条件表达式返回不同的值，如 condition ? expr1 : expr2。
    7. typeof 运算符
      答：用于判断变量的数据类型，如 typeof variable 返回 "number"、"string"、"boolean" 等。
    8. instanceof 运算符
      答：用于判断对象是否是某个构造函数的实例，如 object instanceof Constructor 返回 true 或 false。
    9. delete 运算符
      答：用于删除对象的属性，如 delete object.property 删除对象的指定属性。
    10. void 运算符
      答：用于执行一个表达式并返回 undefined，如 void expression。
    11. in 运算符
      答：用于检查对象是否具有指定的属性，如 "property" in object 返回 true 或 false。
    12. 逗号运算符
      答：用于在一个表达式中执行多个操作，并返回最后一个操作的结果，如 (expr1, expr2) 返回 expr2 的值。
    13. 扩展运算符
      答：用于展开数组或对象，如 [...array] 将数组展开为单独的元素，{...object} 将对象的属性展开为新的对象。
    14. 其他运算符
      答：还有一些其他运算符，如解构赋值（const {a, b} = obj;）、可选链运算符（obj?.property）等。
    15. ?? 空值合并运算符
      答：用于返回第一个非空值，如 a ?? b，当 a 不为 null 或 undefined 时返回 a，否则返回 b。
    注意 Object.is() 方法可以用于比较两个值是否严格相等，类似于 ===，但在处理 NaN 和 -0 与 +0 时有所不同。
  ## 循环遍历的方法
    答：JavaScript中常用的循环遍历方法包括：
    1. for 循环
      答：用于按索引遍历数组或对象属性。
      ```javascript
      for (let i = 0; i < array.length; i++) {
        console.log(array[i]);
      }
      ```
    2. for...in 循环
      答：用于遍历对象的可枚举属性。
      ```javascript
      for (let key in object) {
        console.log(key, object[key]);
      }
      ```
    3. for...of 循环
      答：用于遍历数组、字符串、Map、Set等可迭代对象。
      ```javascript
      for (let value of array) {
        console.log(value);
      }
      ```
    4. Array.forEach() 方法
      答：用于对数组的每个元素执行指定的函数。
      ```javascript
      array.forEach((value, index) => {
        console.log(index, value);
      });
      ```
    5. Array.map() 方法
      答：用于对数组的每个元素执行指定的函数，并返回一个新数组。
      ```javascript
      const newArray = array.map((value, index) => {
        return value * 2; // 返回新数组的元素
      });
      ```
    6. Array.filter() 方法
      答：用于过滤数组的元素，返回一个新数组，其中包含满足条件的元素。
      ```javascript
      const filteredArray = array.filter((value) => {
        return value > 10; // 返回大于10的元素
      });
      ```
    7. Array.reduce() 方法
      答：用于对数组的每个元素执行指定的函数，并返回一个单一的值（累加器）。
      ```javascript
      const sum = array.reduce((accumulator, value) => {
        return accumulator + value; // 累加数组元素
      }, 0); // 初始值为0
      ```
    8. Array.some() 方法
      答：用于检查数组中是否至少有一个元素满足指定条件，返回布尔值。
      ```javascript
      const hasEven = array.some((value) => {
        return value % 2 === 0; // 检查是否有偶数
      });
      ```
    9. Array.every() 方法
      答：用于检查数组中的所有元素是否满足指定条件，返回布尔值。
      ```javascript
      const allPositive = array.every((value) => {
        return value > 0; // 检查是否所有元素都大于0
      });
      ```
    10. Array.find() 方法
      答：用于查找数组中第一个满足指定条件的元素，返回该元素或undefined。
      ```javascript
      const firstEven = array.find((value) => {
        return value % 2 === 0; // 查找第一个偶数
      });
      ```
    11. Array.findIndex() 方法
      答：用于查找数组中第一个满足指定条件的元素的索引，返回该索引或-1。
      ```javascript
      const index = array.findIndex((value) => {
        return value > 10; // 查找第一个大于10的元素的索引
      });
      ```
    12. for await...of 循环
      答：用于异步迭代可迭代对象（如异步生成器）。
      ```javascript
      async function asyncIterator() {
        for await (let value of asyncIterable) {
          console.log(value);
        }
      }
      ```
    13. while 循环
      答：用于在满足条件时重复执行代码块。
      ```javascript
      let i = 0;
      while (i < array.length) {
        console.log(array[i]);
        i++;
      }
      ```
    14. do...while 循环
      答：与while循环类似，但至少执行一次代码块。
      ```javascript
      let i = 0;
      do {
        console.log(array[i]);
        i++;
      } while (i < array.length);
      ```
  ## JS原型和原型链
    1. 原型的概念
      答：原型是JavaScript中实现继承和共享属性的方法。每个对象都有一个原型对象，可以通过__proto__属性访问。
    2. 原型链的概念
      答：原型链是指通过对象的原型属性形成的一条链式结构，用于查找对象的属性和方法。当访问一个对象的属性时，JavaScript会沿着原型链查找，直到找到该属性或到达Object.prototype。
    3. 原型和实例的关系
      答：实例对象可以访问其构造函数的原型对象上的属性和方法。通过原型，可以实现属性和方法的共享，从而节省内存。
    4. 原型链的作用
      答：原型链用于实现继承，使得子类可以访问父类的方法和属性。它还允许多个实例共享相同的方法，从而提高性能。
    5. 原型链的性能问题
      答：过长的原型链可能导致性能问题，因为每次访问属性时都需要沿着原型链查找。为了提高性能，可以使用直接引用或缓存常用属性。
    6. 原型链的实现方式
      答：原型链可以通过以下方式实现：
        - 使用构造函数创建对象，并将方法添加到构造函数的prototype属性上。
        - 使用Object.create()方法创建一个新对象，并指定其原型。
        - 使用class语法定义类，类的原型方法可以通过this访问。
    7. 原型链的注意事项
      答：
        - 修改原型对象会影响所有实例，因此需要谨慎修改。
        - 在访问属性时，如果属性在实例上不存在，JavaScript会沿着原型链查找，直到找到或到达Object.prototype。
        - 使用hasOwnProperty()方法可以判断属性是否为实例自身的属性，而不是从原型链继承的属性。
        - 使用Object.getPrototypeOf()方法可以获取对象的原型。
    8. 三角关系
      答：
      - 在JavaScript中，原型链形成了一个三角关系：对象 -> 原型 -> 原型的原型。每个对象都有一个原型，而原型又可以有自己的原型，这样形成了一个链式结构。
      -
      ```javascript
      function Person(name) {
        this.name = name;
      }
      Person.prototype.greet = function() {
        console.log(`Hello, my name is ${this.name}`);
      };
      const person = new Person('John');
      person.greet(); // 输出 "Hello, my name is John"
      console.log(person.__proto__ === Person.prototype); // 输出 true
      console.log(Person.prototype.__proto__ === Object.prototype); // 输出 true
      console.log(Object.prototype.__proto__); // 输出 null
      ```
    9. 普通对象和构造器对象
      答：普通对象是通过对象字面量或Object.create()等方式创建的对象，而构造器对象是通过构造函数创建的对象。构造器对象的原型链指向构造函数的prototype属性。
        - 只有构造器对象才有prototype属性，普通对象没有。
        - 普通对象的原型是Object.prototype，而构造器对象的原型是构造函数的prototype属性。
        - 无论是普通对象还是构造器对象，最终的constructor指向Function.prototype
        - Function的constructor指向自身。
        - Object这个构造函数的prototype属性指向Object.prototype，而Object.prototype的constructor指向Object。
        - Object实例化的对像的原型对象是Object.prototype,其他构造函数实例化的对象的原型对象是对应构造函数的prototype属性，再向上才是Object.prototype。
    10. 原型链的应用
      答：原型链可以用于实现继承、共享方法和属性、动态添加方法等。通过原型链，可以创建更灵活和可扩展的对象模型。
        - 继承：子类可以通过原型链访问父类的方法和属性。
        - 共享方法：多个实例可以共享同一个方法，节省内存，对于属性来说，所有对象独有一份，但是部分方法是共享的，可以把方法放在原型上，这样所有实例都可以访问同一个方法。
        - 动态添加方法：可以在运行时向原型添加新方法，使得所有实例都能访问。
    11. 原型相关的方法
      答：JavaScript提供了一些方法来操作原型链：
        - Object.getPrototypeOf(obj)：获取对象的原型。
        - Object.setPrototypeOf(obj, prototype)：设置对象的原型。
        - Object.create(prototype)：创建一个新对象，并指定其原型。
        - Object.prototype.hasOwnProperty(prop)：判断对象是否具有指定属性（不包括从原型链继承的属性）。
        - Object.prototype.isPrototypeOf(obj)：判断当前对象是否在指定对象的原型链上。

  ## 创建对象
    1. 使用对象字面量
      答：使用花括号{}创建一个对象。
      ```javascript
      const obj = { key: 'value' };
      ```
    2. 使用构造函数
      答：定义一个函数，并使用new关键字创建对象实例。
      ```javascript
      function Person(name, age) {
        this.name = name;
        this.age = age;
      }
      const person = new Person('John', 30);
      ```
    3. 使用Object.create()
      答：使用Object.create()方法创建一个新对象，并指定其原型。
      ```javascript
      const proto = { greet: function() { console.log('Hello'); } };
      const obj = Object.create(proto);
      obj.greet(); // 输出 "Hello"
      ```
    4. 使用class语法
      答：使用class关键字定义一个类，并使用new关键字创建对象实例。
      ```javascript
      class Person {
        constructor(name, age) {
          this.name = name;
          this.age = age;
        }
        greet() {
          console.log(`Hello, my name is ${this.name}`);
        }
      }
      const person = new Person('John', 30);
      person.greet(); // 输出 "Hello, my name is John"
      ```
    5. 使用工厂函数
      答：定义一个函数，返回一个新对象。
      ```javascript
      function createPerson(name, age) {
        return {
          name: name,
          age: age,
          greet: function() {
            console.log(`Hello, my name is ${this.name}`);
          }
        };
      }
      const person = createPerson('John', 30);
      person.greet(); // 输出 "Hello, my name is John"
      ```
    6. 使用JSON.parse()
      答：将JSON字符串解析为JavaScript对象。
      ```javascript
      const jsonString = '{"name": "John", "age": 30}';
      const obj = JSON.parse(jsonString);
      console.log(obj.name); // 输出 "John"
      ```
    7. 使用Object.assign()
      答：将一个或多个源对象的属性复制到目标对象。
      ```javascript
      const target = {};
      const source = { name: 'John', age: 30 };
      Object.assign(target, source);
      console.log(target); // 输出 { name: 'John', age: 30 }
      ```
    8. 使用Object.fromEntries()
      答：将键值对数组转换为对象。
      ```javascript
      const entries = [['name', 'John'], ['age', 30]];
      const obj = Object.fromEntries(entries);
      console.log(obj); // 输出 { name: 'John', age: 30 }
      ```
  ## new 关键字
    答：用于创建对象实例并调用构造函数。
    1. new 所经历的步骤
      答：使用new关键字创建对象时，经历以下步骤：
        - 创建一个新对象。
        - 将新对象的__proto__属性指向构造函数的prototype属性。
        - 执行构造函数，并将this绑定到新对象上。
        - 如果构造函数返回一个对象，则返回该对象；否则返回新创建的对象。
      ```javascript
      function Person(name) {
        this.name = name;
      }
      const person = new Person('John');

      const obj = {}
      obj.__proto__ = Person.prototype; // 设置原型链
      this->obj; // 将this绑定到新对象上
      Person.call(obj, 'John'); // 执行构造函数
      return obj; // 返回新创建的对象
      ```
  ## 执行栈和执行上下文
    1. js中的执行环境和执行上下文
      - 全局环境、函数环境、eval环境
      - 全局执行上下文、函数执行上下文、eval执行上下文
    2. 什么是执行栈和执行上下文，他们有什么关系
      答：
        1. 执行栈（Call Stack）是一个数据结构，用于管理函数调用的顺序。它是一个后进先出（LIFO）的结构，当一个函数被调用时，它会被压入栈顶，当函数执行完毕时，它会从栈顶弹出。
        2. 执行上下文（Execution Context）是一个抽象概念，表示代码执行时的环境。每当函数被调用时，都会创建一个新的执行上下文。执行上下文包含了变量、函数、this指针等信息。
        3. 执行栈和执行上下文的关系是：每当一个函数被调用时，都会创建一个新的执行上下文，并将其压入执行栈。当函数执行完毕时，对应的执行上下文会从栈顶弹出。

    3. 执行上下文的生命周期
      1. 创建阶段
        - 创建一个新的执行上下文对象。
        - 确定变量对象（Variable Object），包括函数声明、变量声明和参数。
        - 确定作用域链（Scope Chain），用于查找变量和函数。
        - 确定this指针的值。
        注意：在创建阶段，变量和函数声明会被提升，但赋值不会，函数声明会被提升到顶部
      2. 执行阶段
        - 执行代码，初始化变量和函数。
        - 处理函数调用，将新的执行上下文压入执行栈。
      3. 销毁阶段
        - 当函数执行完毕，执行上下文从执行栈中弹出。
        - 如果没有其他引用指向该执行上下文，它将被垃圾回收机制回收。
  ## 作用域和作用域链
    1. 作用域（Scope）
      答：作用域是指变量、函数等标识符的可访问范围
      - 全局作用域：在整个脚本中都可访问的变量和函数。
      - 函数作用域：函数内部的作用域，函数外部无法访问。
      - 块级作用域：使用let、const等关键字定义的变量，只在块级作用域内有效。
    2. 作用域链（Scope Chain）
      答：作用域链是由多个作用域组成的链式结构，用于查找变量和函数。当访问一个变量时，JavaScript会沿着作用域链查找，直到找到该变量或到达全局作用域。
    3. 静态作用域
      答：JavaScript使用静态作用域（Lexical Scope），即变量的作用域在代码编写时就已经确定，而不是在运行时动态决定。函数的作用域由其定义的位置决定，而****不是调用的位置**。
      - 例如：
      ```javascript
      function outer() {
        const x = 10;
        function inner() {
          console.log(x); // 访问外部函数的变量
        }
        inner();
      }
      outer(); // 输出 10
      ```
  ## js中的this
    1. this的概念
      答：this是一个关键字，指向当前执行上下文中的对象。它的值取决于函数的调用方式。
    2. this的指向规则
      答：
        - 全局作用域：在全局作用域中，this指向全局对象（浏览器中为window）。
        - 函数调用：在函数调用时，this指向调用该函数的对象。
        - 方法调用：在对象的方法中，this指向该对象。
        - 构造函数调用：在使用new关键字调用构造函数时，this指向新创建的实例对象。
        - 箭头函数：箭头函数没有自己的this，它会继承外部函数的this。
        - 显式绑定：使用call、apply或bind方法可以显式地设置this的值。
    3. this的应用场景
      答：this常用于访问对象的属性和方法，如事件处理、回调函数等。通过正确理解this，可以避免常见的错误，如在回调函数中丢失上下文。
    4. this的注意事项
      答：
        - 在事件处理函数中，this通常指向触发事件的元素。
        - 在箭头函数中，this不会被重新绑定，而是继承自外部作用域。
        - 使用bind()方法可以创建一个新的函数，并将this绑定到指定对象上。
    5. this的例子
      答：
      ```javascript
      // 全局作用域
      console.log(this); // 在浏览器中输出 window 对象

      // 函数调用
      function showThis() {
        console.log(this);
      }
      showThis(); // 输出 window 对象

      // 方法调用
      const obj = {
        name: 'John',
        greet: function() {
          console.log(`Hello, my name is ${this.name}`);
        }
      };
      obj.greet(); // 输出 "Hello, my name is John"

      // 构造函数调用
      function Person(name) {
        this.name = name;
      }
      const person = new Person('Alice');
      console.log(person.name); // 输出 "Alice"

      // 箭头函数
      const arrowFunc = () => {
        console.log(this);
      };
      arrowFunc(); // 输出全局对象（在浏览器中为 window）

      // 显式绑定
      function showName() {
        console.log(this.name);
      }
      const user = { name: 'Bob' };
      showName.call(user); // 输出 "Bob"
      showName.apply(user); // 输出 "Bob"
      const boundFunc = showName.bind(user);
      boundFunc(); // 输出 "Bob"

      // DOM绑定事件 this 指向触发事件的元素
      const button = document.querySelector('button');
      button.addEventListener('click', function() {
        console.log(this); // 输出触发事件的按钮元素
      });
      ```
  ## 垃圾回收和内存泄漏
    1. 垃圾回收（Garbage Collection）
      答：垃圾回收是JavaScript引擎自动管理内存的机制，用于释放不再使用的内存空间。它通过标记和清除算法来识别和回收不再需要的对象。
    2. 垃圾回收的工作原理
      答：垃圾回收通常使用以下两种算法：
        - 标记清除（Mark-and-Sweep）：标记所有可达的对象，然后清除未被标记的对象。
        - 引用计数（Reference Counting）：跟踪对象的引用计数，当引用计数为0时，回收该对象。
      注意：现代JavaScript引擎通常使用标记清除算法。
    3. 内存泄漏（Memory Leak）
      答：内存泄漏是指程序中未释放的内存空间，导致内存使用量不断增加。常见的内存泄漏原因包括：
        - 全局变量：未清理的全局变量会一直占用内存。
        - 闭包：闭包持有外部函数的引用，可能导致无法释放内存。
        - 事件监听器：未移除的事件监听器会导致对象无法被垃圾回收。
        - 循环引用：两个或多个对象互相引用，导致无法被垃圾回收。
    4. 如何避免内存泄漏
      答：可以通过以下方式避免内存泄漏：
        - 使用局部变量，避免全局变量的使用。
        - 在不需要时及时清理闭包和事件监听器。
        - 使用WeakMap和WeakSet来存储对象引用，这样可以避免循环引用导致的内存泄漏。
        - 定期检查和优化代码，确保没有未使用的对象或资源。
    5. 垃圾回收的触发时机
      答：垃圾回收通常在以下情况下触发：
        - 当内存使用量超过一定阈值时，JavaScript引擎会自动触发垃圾回收。
        - 当执行上下文结束时，相关的局部变量和对象可能会被回收。
        - 在浏览器中，当页面关闭或刷新时，所有相关的内存都会被释放。
      注意：垃圾回收是自动进行的，开发者无法直接控制其触发时机，但可以通过优化代码来减少内存使用。
  ## JS 闭包
    1. 闭包的概念
      答：闭包是指一个函数可以访问其外部作用域中的变量，即使外部函数已经执行完毕。闭包允许函数记住其创建时的作用域。
    2. 闭包的创建方式
      答：闭包通常通过以下方式创建：
        - 在函数内部定义另一个函数，并返回该函数。
        - 使用匿名函数或箭头函数来创建闭包。
      ```javascript
      function outer() {
        const outerVar = 'I am outside!';
        return function inner() {
          console.log(outerVar); // 访问外部变量
        };
      }
      const closureFunc = outer();
      closureFunc(); // 输出 "I am outside!"
      ```
    3. 闭包的应用场景
      答：闭包常用于以下场景：
        - 数据封装：可以将私有变量封装在闭包中，避免外部直接访问。
        - 函数工厂：可以创建具有特定行为的函数，如计数器、缓存等。
        - 事件处理：在事件处理函数中使用闭包，可以访问外部变量。
      ```javascript
      function createCounter() {
        let count = 0;
        return {
          increment: function() {
            count++;
            console.log(count);
          },
          decrement: function() {
            count--;
            console.log(count);
          }
        };
      }
      const counter = createCounter();
      counter.increment(); // 输出 1
      counter.increment(); // 输出 2
      counter.decrement(); // 输出 1
      ```
    4. 闭包的注意事项
      答：
        - 闭包会导致外部变量无法被垃圾回收，可能导致内存泄漏。
        - 使用闭包时要注意变量的作用域，避免意外修改外部变量。
        - 尽量避免在循环中创建闭包，以免产生意外的行为。
    5. 闭包的性能问题
      答：闭包可能会导致性能问题，因为它会增加内存使用和函数调用的开销。为了优化性能，可以：
        - 避免在循环中创建闭包。
        - 使用局部变量而不是全局变量。
        - 在不需要时及时清理闭包，避免内存泄漏。
      ```javascript
      for (let i = 0; i < 5; i++) {
        setTimeout(() => {
          console.log(i); // 输出 0, 1, 2, 3, 4
        }, 1000);
      }
      ```
  ## DOM 注册事件
    1. DOM事件的概念
      答：DOM事件是指用户与网页交互时触发的事件，如点击、键盘输入、鼠标移动等。JavaScript可以通过事件监听器来响应这些事件。
    2. 注册事件的方式
      答：
        - 使用addEventListener()方法注册事件监听器。
        - 使用onclick、onmouseover等属性直接注册事件处理函数。（只能注册一个事件处理函数，后注册的会覆盖前一个）
      ```javascript
      const button = document.querySelector('button');
      button.addEventListener('click', function() {
        console.log('Button clicked!');
      });
      ```
    3. 事件对象
      答：当事件被触发时，浏览器会创建一个事件对象，包含有关事件的信息，如类型、目标元素、鼠标位置等。可以在事件处理函数中访问该对象。
      ```javascript
      button.addEventListener('click', function(event) {
        console.log(event.type); // 输出 "click"
        console.log(event.target); // 输出触发事件的元素
      });
      ```
    4. 事件冒泡和捕获
      答：DOM事件有两种传播方式：冒泡和捕获。
        - 冒泡（Bubbling）：从目标元素开始，向上冒泡到父元素，直到document对象。
        - 捕获（Capturing）：从document对象开始，向下捕获到目标元素。
      可以通过addEventListener()方法的第三个参数来指定是否使用捕获模式。
      ```javascript
      button.addEventListener('click', function(event) {
        console.log('Button clicked!');
      }, true); // true表示使用捕获模式
      ```
    5. 移除事件监听器
      答：可以使用removeEventListener()方法移除已注册的事件监听器。需要确保传入的函数引用与注册时一致。
      ```javascript
      function handleClick(event) {
        console.log('Button clicked!');
      }
      button.addEventListener('click', handleClick);
      // 移除事件监听器
      button.removeEventListener('click', handleClick);
      ```
    6. 事件委托
      答：事件委托是指将事件监听器添加到父元素上，而不是每个子元素上。这样可以减少内存使用和提高性能，尤其是在动态添加或删除子元素时。
      ```javascript
      const list = document.querySelector('ul');
      list.addEventListener('click', function(event) {
        if (event.target.tagName === 'LI') {
          console.log('List item clicked:', event.target.textContent);
        }
      });
      ```
    7. 事件的默认行为
      答：某些事件有默认行为，如点击链接会跳转、提交表单会刷新页面等。
      1. 可以使用event.preventDefault()方法阻止默认行为。
        ```javascript
        const link = document.querySelector('a');
        link.addEventListener('click', function(event) {
          event.preventDefault(); // 阻止链接跳转
          console.log('Link clicked, but no navigation.');
          console.log(event.defaultPrevented); // 输出 true，表示默认行为已被阻止
        });
        ```
      2. 可以使用event.stopPropagation()方法阻止事件冒泡。
        ```javascript
        const button = document.querySelector('button');
        button.addEventListener('click', function(event) {
          event.stopPropagation(); // 阻止事件冒泡
          console.log('Button clicked, but no bubbling.');
        });
      const parent = document.querySelector('.parent');
      parent.addEventListener('click', function() {
        console.log('Parent clicked!');
      });
      ```
    8. 事件的this指向
      答：在事件处理函数中，this通常指向触发事件的元素。如果使用箭头函数，this会继承外部作用域的值。
      ```javascript
      button.addEventListener('click', function() {
        console.log(this); // 输出触发事件的按钮元素
      });
      const arrowButton = document.querySelector('.arrow-button');
      arrowButton.addEventListener('click', () => {
        console.log(this); // 输出全局对象（在浏览器中为 window）
      });
      ```
    9. 事件的节流和防抖
      答：节流和防抖是优化事件处理的技术。
        - 节流（Throttling）：限制事件处理函数的执行频率，如每隔一定时间执行一次。
        - 防抖（Debouncing）：在事件触发后，延迟执行处理函数，直到事件停止触发一段时间后才执行。
      ```javascript
      // 节流示例
      function throttle(func, delay) {
        let lastTime = 0;
        return function(...args) {
          const now = Date.now();
          if (now - lastTime >= delay) {
            lastTime = now;
            func.apply(this, args);
          }
        };
      }
      window.addEventListener('resize', throttle(() => {
        console.log('Window resized!');
      }, 1000));

      // 防抖示例
      function debounce(func, delay) {
        let timeout;
        return function(...args) {
          clearTimeout(timeout);
          timeout = setTimeout(() => {
            func.apply(this, args);
          }, delay);
        };
      }
      window.addEventListener('scroll', debounce(() => {
        console.log('Window scrolled!');
      }, 500));
      ```
    10. 事件的生命周期
      答：事件的生命周期包括以下几个阶段：
        - 触发阶段：用户与页面交互触发事件。
        - 捕获阶段：事件从document对象向下传播到目标元素。
        - 目标阶段：事件到达目标元素，执行对应的事件处理函数。
        - 冒泡阶段：事件从目标元素向上冒泡到document对象。
      可以通过addEventListener()方法的第三个参数来控制是否使用捕获模式。
      ```javascript
      button.addEventListener('click', function(event) {
        console.log('Button clicked!');
      }, false); // false表示使用冒泡模式（默认）
      ```
  ## JS 递归
    1. 递归的概念
      答：递归是指函数直接或间接调用自身的编程技术。递归通常用于解决可以分解为更小子问题的问题。
    2. 递归的基本结构
      答：递归函数通常包含两个部分：
        - 基本情况（Base Case）：用于终止递归的条件。
        - 递归情况（Recursive Case）：函数调用自身以解决更小的子问题。
      ```javascript
      function factorial(n) {
        if (n === 0) {
          return 1; // 基本情况
        }
        return n * factorial(n - 1); // 递归情况
      }
      console.log(factorial(5)); // 输出 120
      ```
    3. 递归的应用场景
      答：递归常用于以下场景：
        - 数学计算：如阶乘、斐波那契数列等。
        - 数据结构遍历：如树、图等数据结构的遍历。
        - 分治算法：将问题分解为更小的子问题进行求解。
      ```javascript
      // 斐波那契数列
      function fibonacci(n) {
        if (n <= 1) {
          return n; // 基本情况
        }
        return fibonacci(n - 1) + fibonacci(n - 2); // 递归情况
      }
      console.log(fibonacci(6)); // 输出 8
      ```
    4. 递归的注意事项
      答：
        - 确保有基本情况以终止递归，避免无限循环。
        - 注意栈溢出问题，过深的递归可能导致浏览器崩溃或报错。
        - 在某些情况下，可以使用迭代方式替代递归，以提高性能和避免栈溢出。
      ```javascript
      function iterativeFibonacci(n) {
        let a = 0, b = 1;
        for (let i = 0; i < n; i++) {
          [a, b] = [b, a + b]; // 使用解构赋值交换变量
        }
        return a;
      }
      console.log(iterativeFibonacci(6)); // 输出 8
      ```
    5. 递归的性能问题
      答：递归可能导致性能问题，尤其是在处理大数据时。每次递归调用都会增加函数调用的开销，可能导致栈溢出。
        - 可以使用尾递归优化（Tail Call Optimization）来减少栈空间的使用，但JavaScript引擎对尾递归的支持有限。
        - 使用动态规划或记忆化技术可以提高递归算法的性能，避免重复计算。
      ```javascript
      // 记忆化斐波那契数列
      const memo = {};
      function memoizedFibonacci(n) {
        if (n in memo) {
          return memo[n]; // 返回已计算的结果
        }
        if (n <= 1) {
          return n; // 基本情况
        }
        memo[n] = memoizedFibonacci(n - 1) + memoizedFibonacci(n - 2); // 递归情况
        return memo[n];
      }
      console.log(memoizedFibonacci(6)); // 输出 8
      ```
  ## 属性描述符
    1. 属性描述符的概念
      答：属性描述符是一个对象，用于描述对象属性的特性，如可写性、可枚举性、可配置性等。JavaScript提供了Object.defineProperty()方法来定义属性描述符。
    2. 属性描述符的类型
      答：属性描述符分为两种类型：
        - 数据属性描述符（Data Property Descriptor）：包含值和可写性。
        - 访问器属性描述符（Accessor Property Descriptor）：包含getter和setter函数。
      ```javascript
      const obj = {};
      Object.defineProperty(obj, 'name', {
        value: 'John',
        writable: true,
        enumerable: true,
        configurable: true
      });
      console.log(obj.name); // 输出 "John"
      ```
    3. 数据属性描述符的特性
      答：数据属性描述符包含以下特性：
        - value：属性的值。
        - writable：布尔值，表示属性是否可写。
        - enumerable：布尔值，表示属性是否可枚举。
        - configurable：布尔值，表示属性是否可以被删除或修改。
      ```javascript
      Object.defineProperty(obj, 'age', {
        value: 30,
        writable: false, // 不可写
        enumerable: true,
        configurable: false // 不可删除或修改
      });
      console.log(obj.age); // 输出 30
      obj.age = 31; // 无效操作，age属性不可写
      console.log(obj.age); // 仍然输出 30
      ```
    4. 访问器属性描述符的特性
      答：访问器属性描述符包含以下特性：
        - get：一个函数，用于获取属性值。
        - set：一个函数，用于设置属性值。
        - enumerable：布尔值，表示属性是否可枚举。（是否会被for/in和Object.keys()等方法遍历）
        - configurable：布尔值，表示该对象的属性是否可以被删除或修改。
      ```javascript
      Object.defineProperty(obj, 'fullName', {
        get: function() {
          return `${this.name} Doe`;
        },
        set: function(value) {
          this.name = value.split(' ')[0];
        },
        enumerable: true,
        configurable: true
      });
      console.log(obj.fullName); // 输出 "John Doe"
      obj.fullName = 'Alice Smith';
      console.log(obj.name); // 输出 "Alice"
      ```
    5. 属性描述符的应用场景
      答：属性描述符常用于以下场景：
        - 定义只读属性：通过设置writable为false，可以创建只读属性。
        - 创建计算属性：使用getter和setter函数，可以创建动态计算的属性。
        - 控制属性的可见性：通过设置enumerable为false，可以隐藏属性，使其不出现在for...in循环中。
        - 定义不可配置的属性：通过设置configurable为false，可以防止属性被删除或修改。
      ```javascript
      Object.defineProperty(obj, 'hidden', {
        value: 'This is hidden',
        enumerable: false // 不可枚举
      });
      console.log(obj.hidden); // 输出 "This is hidden"
      for (const key in obj) {
        console.log(key); // 不会输出 "hidden"
      }
      ```
    6. 属性描述符的注意事项
      答：
        - 使用Object.defineProperty()定义属性时，如果属性已存在，则会覆盖原有的属性描述符。
        - 如果要修改现有属性的特性，需要将configurable设置为true，否则无法修改。
        - 访问器属性描述符不能同时包含value和writable特性，只能选择一种类型。
        - 属性描述符的默认值：如果未显式设置某个特性，默认为false（除value外）。
      ```javascript
      Object.defineProperty(obj, 'newProp', {
        value: 'New Property',
        writable: true // 可写
      });
      console.log(obj.newProp); // 输出 "New Property"
      obj.newProp = 'Updated Property';
      console.log(obj.newProp); // 输出 "Updated Property"
      ```
  ## Object 常用对象方法
    答：JavaScript的Object对象提供了一些常用的方法来操作对象，这些方法包括：
      1. Object.keys(obj)
        - 返回一个包含对象自身可枚举属性名的数组。
      2. Object.values(obj)
        - 返回一个包含对象自身可枚举属性值的数组。
      3. Object.entries(obj)
        - 返回一个包含对象自身可枚举属性键值对的数组，每个键值对是一个数组。
      4. Object.assign(target, ...sources)
        - 将一个或多个源对象的属性复制到目标对象，并返回目标对象。
      5. Object.freeze(obj)
        - 冻结对象，使其不可修改（不能添加、删除或修改属性）。
      6. Object.seal(obj)
        - 密封对象，使其不可添加新属性，但可以修改现有属性的值。
      7. Object.isFrozen(obj)
        - 检查对象是否被冻结，返回布尔值。
      8. Object.getOwnPropertyDescriptor(obj, prop)
        - 返回指定属性的属性描述符对象，包含该属性的特性（如value、writable、enumerable、configurable）。
      9. Object.defineProperty(obj, prop, descriptor)
        - 定义或修改对象的属性，并可以设置属性的特性（如value、writable、enumerable、configurable）。
      10. Object.defineProperties(obj, descriptors)
        - 定义或修改对象的多个属性，descriptors是一个包含多个属性描述符的对象。
      11. Object.getOwnPropertyNames(obj)
        - 返回一个包含对象自身所有属性名的数组，包括不可枚举属性。
      12. Object.getPrototypeOf(obj)
        - 返回对象的原型（即该对象的__proto__属性）。
      13. Object.setPrototypeOf(obj, prototype)
        - 设置对象的原型为指定的对象，并返回该对象。
      14. Object.create(proto, propertiesObject)
        - 创建一个新对象，使用指定的原型对象和可选的属性描述符。
      15. Object.fromEntries(iterable)
        - 将一个键值对的可迭代对象（如数组）转换为对象。
      16. Object.is(value1, value2)
        - 判断两个值是否严格相等，类似于===，但处理NaN和+0/-0的方式不同。
  ##  Array 常用方法
    答：JavaScript的Array对象提供了许多常用的方法来操作数组，这些方法包括：
      1. Array.isArray(value)
        - 检查给定的值是否为数组，返回布尔值。
      2. array.push(...items)
        - 向数组末尾添加一个或多个元素，并返回新数组的长度。
      3. array.pop()
        - 从数组末尾删除一个元素，并返回该元素。
      4. array.shift()
        - 从数组开头删除一个元素，并返回该元素。
      5. array.unshift(...items)
        - 向数组开头添加一个或多个元素，并返回新数组的长度。
      6. array.concat(...items)
        - 合并两个或多个数组，并返回新数组。
      7. array.slice(start, end)
        - 返回数组的一个浅拷贝，包含从start到end（不包括end）的元素。
      8. array.splice(start, deleteCount, ...items)
        - 从数组中添加或删除元素，返回被删除的元素。
      9. array.indexOf(searchElement, fromIndex)
        - 返回指定元素在数组中的第一个索引，如果未找到则返回-1。
      11. array.includes(searchElement, fromIndex)
        - 检查数组是否包含指定元素，返回布尔值。
      12. array.forEach(callback(currentValue, index, array), thisArg)
        - 对数组的每个元素执行一次提供的函数。
      13. array.map(callback(currentValue, index, array), thisArg)
        - 创建一个新数组，包含对原数组每个元素调用提供函数后的结果。
      14. array.filter(callback(currentValue, index, array), thisArg)
        - 创建一个新数组，包含所有通过测试的元素。
      15. array.reduce(callback(accumulator, currentValue, index, array), initialValue)
        - 对数组中的每个元素执行一次提供的函数，将其结果汇总为单个值。
      17. array.find(callback(currentValue, index, array), thisArg)
        - 返回数组中满足提供测试函数的第一个元素，如果没有找到则返回undefined。
      18. array.findIndex(callback(currentValue, index, array), thisArg)
        - 返回数组中满足提供测试函数的第一个元素的索引，如果没有找到则返回-1。
      19. array.some(callback(currentValue, index, array), thisArg)
        - 检查数组中是否至少有一个元素满足提供的测试函数，返回布尔值。
      20. array.every(callback(currentValue, index, array), thisArg)
        - 检查数组中是否所有元素都满足提供的测试函数，返回布尔值。
      21. array.sort(compareFunction)
        - 对数组元素进行排序，并返回排序后的数组。compareFunction用于定义排序顺序。
      22. array.reverse()
        - 反转数组中的元素顺序，并返回反转后的数组。
      23. array.join(separator)
        - 将数组的所有元素连接成一个字符串，使用指定的分隔符（默认为逗号）。
      24. array.toString()
        - 将数组转换为字符串，等同于array.join(',')。
      25. array.flat(depth)
        - 将多维数组扁平化为一维数组，depth指定扁平化的深度（默认为1）。
      28. array.fill(value, start, end)
        - 用指定的值填充数组的指定范围，返回修改后的数组。
  ## Reflect
    答：Reflect是一个内置对象，提供了一些方法来操作对象的属性和行为。它的主要目的是提供与Object对象相似的功能，但具有更一致的行为和更好的错误处理。
    1. Reflect.get(target, propertyKey, receiver)
      - 获取对象target上指定属性propertyKey的值，receiver用于处理getter函数中的this指向。
    2. Reflect.set(target, propertyKey, value, receiver)
      - 设置对象target上指定属性propertyKey的值为value，receiver用于处理setter函数中的this指向。
    3. Reflect.has(target, propertyKey)
      - 检查对象target是否具有指定属性propertyKey，返回布尔值。
    4. Reflect.deleteProperty(target, propertyKey)
      - 删除对象target上指定属性propertyKey，并返回布尔值表示删除是否成功。
    5. Reflect.apply(target, thisArgument, argumentsList)
      - 调用函数target，并将this指向thisArgument，传入参数argumentsList。
    6. Reflect.construct(target, argumentsList[, newTarget])
      - 使用new关键字调用构造函数target，并传入参数argumentsList，newTarget用于指定构造函数的原型。
    7. Reflect.defineProperty(target, propertyKey, attributes)
      - 定义或修改对象target上的属性propertyKey，使用attributes描述符。
    8. Reflect.getOwnPropertyDescriptor(target, propertyKey)
      - 返回对象target上指定属性propertyKey的属性描述符。
    9. Reflect.getPrototypeOf(target)
      - 返回对象target的原型（即__proto_  _）。
    10. Reflect.setPrototypeOf(target, prototype)
      - 设置对象target的原型为prototype，并返回布尔值表示设置是否成功。
    11. Reflect.isExtensible(target)
      - 检查对象target是否可扩展（即是否可以添加新属性），返回布尔值。
    12. Reflect.preventExtensions(target)
      - 防止对象target添加新属性，并返回布尔值表示操作是否成功。
    13. Reflect.ownKeys(target)
      - 返回对象target的所有自身属性键，包括不可枚举属性和Symbol属性。
  ## Proxy
    答：Proxy是一个内置对象，用于创建一个代理对象，以便在访问目标对象时可以自定义其行为。通过Proxy，可以拦截和修改对目标对象的基本操作，如属性访问、赋值、枚举、函数调用等。
    1. new Proxy(target, handler)
      - 创建一个新的代理对象，target是要代理的目标对象，handler是一个对象，用于定义代理的行为。
    2. handler.get(target, property, receiver)
      - 拦截对target对象属性的访问，property是要访问的属性名，receiver是用于处理getter函数中的this指向。
    3. handler.set(target, property, value, receiver)
      - 拦截对target对象属性的赋值，property是要赋值的属性名，value是要赋的值，receiver是用于处理setter函数中的this指向。
    4. handler.has(target, property)
      - 拦截对target对象属性的存在性检查，property是要检查的属性名。
    5. handler.deleteProperty(target, property)
      - 拦截对target对象属性的删除，property是要删除的属性名。
    6. handler.apply(target, thisArg, argumentsList)
      - 拦截对target函数的调用，thisArg是函数调用时的this指向，argumentsList是传入的参数列表。
    7. handler.construct(target, argumentsList, newTarget)
      - 拦截对target构造函数的调用，argumentsList是传入的参数列表，newTarget用于指定构造函数的原型。
  ## class 和 构造函数的区别
    答：JavaScript中的class和构造函数都是用于创建对象的方式，但它们有一些区别：
    1. 语法
      - class使用class关键字定义，具有更清晰的语法结构。
      - 构造函数使用function关键字定义，通常以 大写字母开头。
      ```javascript
      // class定义
      class Person {
        constructor(name) {
          this.name = name;
        }
        greet() {
          console.log(`Hello, my name is ${this.name}`);
        }
      }

      // 构造函数定义
      function PersonConstructor(name) {
        this.name = name;
      }
      PersonConstructor.prototype.greet = function() {
        console.log(`Hello, my name is ${this.name}`);
      };
      ```
    2. 原型链
      - class自动创建一个原型对象，并将方法添加到该原型上。
      - 构造函数需要手动将方法添加到原型上。
    3. 继承
      - class使用extends关键字进行继承，语法更简洁。
      - 构造函数使用Object.create()或call/apply来实现继承。
      ```javascript
      // class继承
      class Student extends Person {
        constructor(name, grade) {
          super(name); // 调用父类构造函数
          this.grade = grade;
        }
        study() {
          console.log(`${this.name} is studying.`);
        }
      }

      // 构造函数继承
      function StudentConstructor(name, grade) {
        PersonConstructor.call(this, name); // 调用父类构造函数
        this.grade = grade;
      }
      StudentConstructor.prototype = Object.create(PersonConstructor.prototype);
      StudentConstructor.prototype.constructor = StudentConstructor;
      StudentConstructor.prototype.study = function() {
        console.log(`${this.name} is studying.`);
      };
      ```
    4. 静态方法
      - class可以定义静态方法，使用static关键字。
      - 构造函数没有内置的静态方法语法，需要手动添加到构造函数上。
      ```javascript
      class MathUtils {
        static add(a, b) {
          return a + b;
        }
      }

      function MathUtilsConstructor() {}
      MathUtilsConstructor.add = function(a, b) {
        return a + b;
      };
      ```
    5. this指向
      - 在class中，this指向实例对象。
      - 在构造函数中，this指向新创建的对象。
      ```javascript
      const person = new Person('Alice');
      person.greet(); // 输出 "Hello, my name is Alice"

      const personConstructor = new PersonConstructor('Bob');
      personConstructor.greet(); // 输出 "Hello, my name is Bob"
      ```
    6. 可读性和可维护性
      - class语法更接近其他面向对象编程语言（如Java、C#），更易于理解和维护。
      - 构造函数语法较为传统，可能对新手不太友好。
    7. 兼容性
      - class是ES6引入的语法，较新版本的JavaScript支持。
      - 构造函数是JavaScript的传统语法，兼容性更好，支持更早版本的JavaScript。
    8. Babel的实现
      - Babel等编译工具可以将class语法转换为构造函数语法，以便在不支持ES6的环境中使用。
      - 这使得class语法可以在旧版本的浏览器或JavaScript引擎中运行。
      ```javascript
      // Babel转换后的代码示例
      var Person = function(name) {
        this.name = name;
      };
      Person.prototype.greet = function() {
        console.log(`Hello, my name is ${this.name}`);
      };
      ```
  ## 浮点数精度问题
    答：JavaScript中的浮点数使用IEEE 754标准表示，这可能导致精度问题，尤其是在进行数学运算时。常见的浮点数精度问题包括：
    1. 精度丢失
      - 由于二进制表示法的限制，一些十进制数无法精确表示，如0.1和0.2。
      - 例如，0.1 + 0.2 !== 0.3，实际结果为0.30000000000000004。
      ```javascript
      console.log(0.1 + 0.2); // 输出 0.30000000000000004
      ```
    2. 四舍五入误差
      - 在进行四舍五入操作时，可能会出现意外的结果。
      - 例如，Math.round(0.1 + 0.2) !== Math.round(0.3)。
      ```javascript
      console.log(Math.round(0.1 + 0.2)); // 输出 0
      console.log(Math.round(0.3)); // 输出 0
      ```
    3. 大数计算问题
      - 当处理非常大的或非常小的浮点数时，可能会出现精度问题。
      - 例如，1e20 + 1 !== 1e20，因为1在大数中被忽略了。
      ```javascript
      console.log(1e20 + 1); // 输出 1e20
      ```
    4. 使用整数代替浮点数
      - 为了避免浮点数精度问题，可以将所有数字转换为整数进行计算，然后再转换回浮点数。
      - 例如，将金额以分为单位存储和计算。
      ```javascript
      const price = 100; // 单位为分
      const tax = 5; // 单位为分
      const total = (price + tax) / 100; // 转换为元单位
      console.log(total); // 输出 1.05
      ```
    5. 使用第三方库
      - 可以使用第三方库（如math.js、Decimal.js、Big.js等）来处理浮点数精度问题，这些库提供了更精确的数学运算。
      ```javascript
      // 使用Decimal.js库
      const Decimal = require('decimal.js');
      const result = new Decimal(0.1).plus(new Decimal(0.2));
      console.log(result.toString()); // 输出 "0.3"
      ```
    6. 使用toFixed()方法
      - 可以使用toFixed()方法将浮点数格式化为指定的小数位数，但要注意它返回的是字符串。
      - 例如，(0.1 + 0.2).toFixed(2)会返回"0.30"。
      ```javascript
      const sum = (0.1 + 0.2).toFixed(2);
      console.log(sum); // 输出 "0.30"
      ```
  ## 严格模式
    答：严格模式（Strict Mode）是JavaScript的一种运行模式，可以通过在脚本或函数的开头添加"use strict";来启用。它可以帮助开发者编写更安全、更高效的代码，避免一些常见的错误。
    1. 启用严格模式
      - 在脚本的开头或函数内部添加"use strict";。
      ```javascript
      "use strict";
      function myFunction() {
        // 严格模式下的代码
      }
      ```
    2. 严格模式的特点
      - 禁止使用未声明的变量：在严格模式下，使用未声明的变量会抛出错误。
      ```javascript
      "use strict";
      x = 10; // 抛出 ReferenceError: x is not defined
      ```
      - 禁止删除变量、函数和参数：在严格模式下，不能删除变量、函数或参数。
      ```javascript
      "use strict";
      var y = 20;
      delete y; // 抛出 SyntaxError: Delete of an unqualified identifier in strict mode.
      ```
