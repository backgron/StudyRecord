# HTML
  ## 盒模型
    1. 两种和盒模型
      答：标准盒模型和IE盒模型
        - 标准盒模型：width和height只包含内容区域，不包括padding、border和margin
        - IE盒模型：width和height包含内容、padding和border，但不包括margin
    2. 盒模型的组成部分（内容、内边距、边框、外边距）
      答：
        - 内容：实际显示的内容区域
        - 内边距：内容与边框之间的空间
        - 边框：包裹内容和内边距的边框
        - 外边距：元素与其他元素之间的空间
    3. 盒模型的计算方式（标准盒模型和IE盒模型）
      答：
        - 标准盒模型：width = content
        - IE盒模型：width = content + padding + border
  ## 语义化标签
    1. 对语义化标签的理解
      答：语义化标签是指那些具有明确含义的HTML标签，它们不仅描述了内容的结构，还提供了关于内容的额外信息，有助于搜索引擎和辅助技术理解页面内容。
    2. 常见的语义化标签（如：header、footer、article、section等）
      答：
        - header：定义文档的头部区域，通常包含导航链接和标题
        - footer：定义文档的底部区域，通常包含版权信息和联系信息
        - article：定义独立的内容块，如文章或博客帖子
        - section：定义文档中的一个章节或部分

  ## 对W3C的理解和认识
    1. W3C的全称和作用
      答：W3C（World Wide Web Consortium）是万维网联盟，负责制定Web标准和指导方针，以确保Web的长期发展和互操作性。
    2. W3C标准的重要性
      答：W3C标准确保了Web内容在不同浏览器和设备上的一致性和可访问性，有助于提高用户体验和Web的可用性。

  ## 说说SEO
    1. SEO的概念 TDK是什么
      答：SEO（Search Engine Optimization）是指通过优化网站结构、内容和外部链接等方式，提高网站在搜索引擎结果中的排名，从而增加网站的可见性和访问量。
      TDK是指标题（Title）、描述（Description）和关键词（Keywords），是SEO优化的重要组成部分。
    2. SEO的优化方式（内部优化、外部优化）
      答：
        - 内部优化：包括网站结构优化、内容优化、关键词布局、页面加载速度等
        - 外部优化：包括外部链接建设、社交媒体推广、品牌曝光等
  ## iframe
    1. iframe的概念
      答：iframe（内联框架）是HTML中的一个元素，用于在当前页面中嵌入另一个HTML页面。它允许在一个页面中显示来自其他来源的内容。
    2. iframe的优缺点
      答：
        - 优点：可以嵌入外部内容，支持跨域加载，便于内容更新和维护
        - 缺点：可能影响页面加载速度，存在安全性问题（如XSS攻击），对SEO不友好
  ## 微格式
    1. 微格式的概念
      答：微格式是一种在HTML中嵌入结构化数据的方式，通过使用特定的类名和属性，使得搜索引擎和其他应用程序能够更好地理解页面内容的含义。
    2. 微格式的作用
      答：微格式可以帮助搜索引擎更好地解析和索引页面内容，提高搜索结果的相关性和可见性，同时也有助于改善用户体验。
  ## 替换元素
    1. 替换元素的概念
      答：替换元素是指那些在渲染时会被浏览器替换为其他内容的HTML元素，如图片、输入框等。这些元素的实际显示内容由浏览器决定，而不是由CSS样式控制。
    2. 替换元素的特点
      答：替换元素通常具有固定的宽度和高度，浏览器会根据其内容类型（如图片、视频等）来渲染它们。它们的样式属性（如margin、padding等）可能会受到限制。
    3. 常见的替换元素（如：img、input、textarea等）
      答：常见的替换元素包括：
        - img：用于显示图片
        - input：用于用户输入
        - textarea：用于多行文本输入
    4. 替换元素与非替换元素的区别
      答：替换元素的内容由浏览器决定，而非替换元素的内容由CSS样式控制。替换元素通常具有固定的尺寸，而非替换元素的尺寸可以通过CSS调整。
  ## 页面可见性API
    1. 页面可见性的概念
      答：页面可见性API是一种用于检测和响应页面可见性变化的API，它可以帮助开发者了解页面何时在用户视口中可见，何时被隐藏。
    2. 页面可见性的影响因素
      答：影响页面可见性的因素包括浏览器窗口的大小、页面的滚动位置、其他元素的遮挡等。
    3. 页面可见性的应用场景
      答：页面可见性API可以用于实现懒加载、广告展示、视频播放等功能，以提高用户体验和页面性能。

# CSS
  ## CSS中有那些单位
    1. CSS中常见的单位
      答：CSS中常见的单位包括：
        - px（像素）：绝对单位，表示屏幕上的一个点
        - em：相对单位，基于父元素的字体大小
        - rem：相对单位，基于根元素（html）的字体大小
        - %（百分比）：相对单位，基于父元素的尺寸
        - vw（视口宽度）：相对于视口宽度的百分比
        - vh（视口高度）：相对于视口高度的百分比
        - vmin/vmax：相对于视口最小/最大尺寸的百分比

  ## 居中方式有那些
    1. 水平居中方式
      答：水平居中的方式包括：
        - 使用margin: auto；（适用于块级元素）
        - 使用text-align: center；（适用于行内元素或行内块元素）
        - 使用flexbox布局（设置父元素为display: flex; justify-content: center;）
        - 使用grid布局（设置父元素为display: grid; place-items: center;）
    
    2. 垂直居中方式
      答：垂直居中的方式包括：
        -  vertical-align: middle;（适用于行内元素或行内块元素）
        - 使用line-height与元素高度相等（适用于 单行文本）
        - 使用flexbox布局（设置父元素为display: flex; align-items: center;）
        - 使用grid布局（设置父元素为display: grid; place-items: center;）
        - 使用绝对定位（设置top、bottom、left、right为0，并使用margin:auto;）
        - 使用transform（设置transform: translateY(-50%);，并设置top为50%）

  ## 隐藏元素
    1. 隐藏元素的方式
      答：隐藏元素的方式包括：
        - H5新增的hidden属性（如：<div hidden></div>）
        - display:  none;（完全移除元素，不占据空间）
        - visibility: hidden;（隐藏元素，但仍占据空间）
        - opacity: 0;（使元素透明，但仍占据空间）
        - position: absolute; left: -9999px;（将元素移出视口）
        - 使用CSS类切换来控制显示和隐藏
    
    2. 隐藏元素的优缺点
      答：
        - display: none; 优点：完全移除元素，缺点：无法通过CSS样式访问
        - visibility: hidden; 优点：保留空间，缺点：仍然不可见
        - opacity: 0; 优点：可以通过CSS样式访问，缺点：仍然占据空间
        - position: absolute; left: -9999px; 优点：可以通过CSS样式访问，缺点：仍然占据空间
  ## 浮动
    1. 浮动的特性
      答：浮动是CSS中的一种布局方式，通过将元素设置为float属性，可以使元素脱离正常的文档流，并向左或向右浮动。浮动元素会影响其后续元素的布局。
        - 脱离文档流
        - 变成行内块元素
        - 影响后续元素的布局
    2. 浮动的应用场景
      答：
        - 文字环绕图片：通过将图片设置为浮动，可以实现文字环绕在图片周围的效果。
        - 多列布局：使用浮动可以创建多列布局，使元素并排显示。
        - 自适应布局：结合媒体查询和浮动，可以实现响应式布局。
    3. 浮动的缺点
      答：
        - 浮动元素可能会导致父元素高度塌陷，需要使用clearfix等方法清除浮动。
        - 浮动元素的布局可能会受到其他元素的影响，导致意外的布局问题。
        - 浮动元素在某些情况下可能会导致浏览器渲染性能下降。
    4. 清除浮动的方法
      答：清除浮动的方法包括：
        - 给父元素设置高度（要大于浮动子元素的高度）
        - 使用clearfix类：在父元素上添加一个clearfix类，通过伪元素::after清除浮动。
        - 使用overflow属性：设置父元素的overflow属性为hidden或auto，可以清除浮动。
        - 使用空元素：在浮动元 素后添加一个空的div，并设置clear: both;（会让margin和padding失效）
        - 使用CSS Flexbox或Grid布局替代浮动布局。
  ## 定位
    1. 定位的概念
      答：定位是CSS中的一种布局方式，通过设置元素的position属性，可以控制元素在页面中的位置。常见的定位方式包括静态定位、相对定位、绝对定位、固定定位和粘性定位。
    2. 定位的类型
      答：
        - 静态定位（static）：默认定位方式，元素按照文档流正常排列，不受top、right、bottom、left属性影响。
        - 相对定位（relative）：相对于元素自身的原始位置进行偏移，可以使用top、right、bottom、left属性进行调整。
        - 绝对定位（absolute）：相对于最近的已定位祖先元素进行定位，如果没有已定位祖先，则相对于初始包含块（通常是html或body）。
        - 固定定位（fixed）：相对于浏览器窗口进行定位，元素在页面滚动时保持在固定位置。
        - 粘性定位（sticky）：结合了相对定位和固定定位，当元素在视口中滚动到指定位置时，会变为固定定位。
    3. 定位的应用场景
      答：
        - 相对定位：用于微调元素位置，常用于创建悬停效果或工具提示。
        - 绝对定位：用于创建弹出菜单、模态框等，需要脱离文档流的元素。
        - 固定定位：用于创建固定在视口中的导航栏、页脚等。
        - 粘性定位：用于创建在滚动时保持在视口中的元素，如粘性导航栏。
    4. 定位的优缺点
      答：
        - 相对定位：优点是可以微调元素位置，缺点是仍然占据文档流空间。
        - 绝对定位：优点是可以脱离文档流，灵活控制位置，缺点是可能导致布局问题，需要清除浮动，盒子会变成block元素。
        - 固定定位：优点是元素在视口中保持固定位置，缺点是可能影响页面滚动体验。
        - 粘性定位：优点是结合了相对和固定定位的优点，缺点是浏览器兼容性较差。
  ## BFC
    1. BFC的概念
      答：BFC（Block Formatting Context）是CSS中的一个布局概念，它是一个独立的渲染区域，元素在BFC中按照块级格式化规则进行布局。BFC可以防止外边距合并、清除浮动等问题。
    2. BFC的触发条件
      答：触发BFC的条件包括：
        - 根元素（html、body）
        - 浮动元素（float不为none）
        - 绝对定位元素（position为absolute或fixed）
        - inline-block元素（display为inline-block）
        - overflow属性不为visible（如：overflow: hidden;）
        - display属性为flex或grid
    3. BFC的作用
      答：
        - 防止外边距合并：BFC内的元素不会与外部元素的外边距合并。
        - 清除浮动：BFC可以包含浮动元素，避免父元素高度塌陷。
        - 控制布局：BFC可以控制元素的布局和定位，使其独立于其他元素。
    4. BFC的应用场景
      答：
        - 创建独立的布局区域，如弹出菜单、模态框等。
        - 清除浮动，避免父元素高度塌陷。
        - 控制外边距，避免外边距合并导致布局问题。
    5. BFC的规则
      答：
        - BFC内的元素不会与外部元素的外边距合并。
        - BFC内的元素按照块级格式化规则进行布局。
        - BFC内的元素可以包含浮动元素，避免父元素高度塌陷。
        - BFC内的元素不会影响外部元素的布局。
    6. BFC、IFC、GFC、FFC的区别
      答：
        - BFC（Block Formatting Context）：块级格式化上下文，主要用于控制块级元素的布局和外边距合并。
        - IFC（Inline Formatting Context）：行内格式化上下文，主要用于控制行内元素的布局和换行。
        - GFC（Grid Formatting Context）：网格格式化上下文，主要用于CSS Grid布局。
        - FFC（Flex Formatting Context）：弹性格式化上下文，主要用于CSS Flexbox布局。
  ## CSS属性的计算过程
    1. CSS属性的计算过程
      答：CSS属性的计算过程包括以下几个步骤：
        - 解析：浏览器解析CSS规则，将其转换为内部表示形式。
        - 计算：浏览器根据元素的样式和布局规则计算每个元素的最终样式值。
        - 应用：将计算后的样式应用到元素上，渲染页面。
    2. CSS属性的优先级
      答：CSS属性的优先级由以下几个因素决定：
        - 内联样式（最高优先级） 1000
        - ID选择器 100
        - 类选择器、属性选择器和伪类选择器 10
        - 元素选择器和伪元素选择器 1
        - 通配符选择器 '*'（最低优先级） * 0
    3. CSS属性的继承
      答：CSS属性的继承是指某些样式属性会从父元素继承到子元素，如字体、颜色等。非继承属性（如margin、padding等）不会被继承。
    4. CSS属性的计算顺序
      答：确定声明值->层叠冲突->使用继承->使用默认
  ## CSS属性的层叠继承规则
    答：重要性 > 专用性 > 源代码次序
      - 层叠顺序：后定义的样式优先级更高。
      - 继承规则：可继承属性从父元素继承，非继承属性使用（就近原则）。
      - 优先级：内联样式 > ID选择器 > 类选择器 > 元素选择器 > 通配符选择器。
      - 重要性：使用!important标记的样式优先级最高。
  ## 引入CSS
    1. 引入CSS的方式
      答：引入CSS的方式包括：
        - 内联样式\嵌入（style属性）：直接在HTML元素中使用style属性定义样式。
        - 内部样式表\内联（<style>标签）：在HTML文档的<head>部分使用<style>标签定义样式。
        - 外部样式表\外联（<link>标签）：使用<link>标签链接外部CSS文件。
        - @import规则：在CSS文件或者<style>中使用@import语句导入其他CSS文件。
    2. 引入CSS的优缺点
      答：
        - 内联样式：优点是快速应用样式，缺点是难以维护和复用。
        - 内部样式表：优点是可以集中管理样式，缺点是无法在多个页面复用。
        - 外部样式表：优点是易于维护和复用，缺点是需要额外的HTTP请求加载CSS文件。
        - @import规则：支持媒体查询，优点是可以按需加载样式，缺点是加载顺序可能影响样式应用，且会增加HTTP请求。
        - JS控制DOM只能使用link，无法使用@import
        - 性能优化来看避免使用@import，因为会增加额外的HTTP请求和加载时间。
  ## calc
    1. calc的概念
      答：calc()是CSS中的一个函数，用于在样式中进行动态计算，可以结合不同的单位进行数学运算，如加法、减法、乘法和除法。
    2. calc的使用场景
      答：calc()常用于需要动态计算尺寸、位置或其他样式属性的场景，如响应式布局、复杂的定位等。
    3. calc的语法
      答：calc()的基本语法为：calc(expression)，其中expression可以是数字、单位和运算符（如+、-、*、/）。
    4. calc的注意事项
      答：
        - 运算符两边必须有空格。
        - 不支持混合使用百分比和绝对单位（如px）。
        - 在某些情况下，可能会影响性能，需谨慎使用。
  ## 媒体查询 media
    1. 媒体查询的概念
      答：媒体查询是CSS中的一种技术，用于根据设备的特性（如屏幕宽度、高度、分辨率等）应用不同的样式。它使得响应式设计成为可能。
    2. 媒体查询的语法
      答：媒体查询的基本语法为：
        ```css
        @media media-type and (condition) {
          /* CSS规则 */
        }
        @media screen and (min-width: 600px) {
          body {
            background-color: lightblue;
          }
        }
        ```
        其中，media-type可以是all、screen、print等（默认是all，media-type and 可以不写），condition可以是min-width、max-width等，可以用and连接多个条件。
    3. 媒体查询的使用场景
      答：媒体查询常用于响应式设计，根据不同设备的屏幕尺寸和特性应用不同的样式，以提高用户体验。
    4. 媒体查询的优缺点
      答：
        - 优点：可以针对不同设备应用不同样式，提高用户体验和可访问性。
        - 缺点：可能增加CSS文件大小，影响加载性能，需要谨慎使用。
  ## 过度和动画
    1. 过渡的概念
      答：过渡是CSS中的一种效果，用于在元素的样式变化时创建平滑的动画效果。通过定义transition属性，可以指定过渡的属性、持续时间、延迟等。
    2. 过渡的语法
      答：过渡的基本语法为：
        ```css
        transition: property duration timing-function delay;
        ```
        其中，property是要过渡的CSS属性，duration是过渡持续时间，timing-function是过渡曲线（如ease、linear等），delay是延迟时间。
    3. 过渡事件
      答：过渡事件是指在过渡效果开始、结束或中断时触发的事件，如transitionstart、transitionend和transitioncancel。这些事件可以用于执行特定的JavaScript代码，以响应过渡效果。
    
    4. 动画的概念
      答：动画是CSS中的一种效果，用于创建复杂的动画效果，可以通过@keyframes规则定义动画帧，并使用animation属性应用到元素上。
    5. 动画的语法
      答：动画的基本语法为：
        ```css
        @keyframes animation-name {
          from { /* 初始状态 */ }
          to { /* 结束状态 */ }
        }
        @keyframes animation-name {
          0% { /* 初始状态 */ }
          100% { /* 结束状态 */ }
        }
        div{
          animation: animation-name duration timing-function delay iteration-count direction fill-mode;
          animation-play-state: paused; /* 暂停动画 running 启动 */
          animation-fill-mode: forwards; /* 保持动画结束状态 */
        }
        ```
        其中，animation-name是动画名称，duration是动画持续时间，timing-function是动画曲线，delay是延迟时间，iteration-count是迭代次数，direction是方向（如normal、reverse等），fill-mode是填充模式（如forwards、backwards等）。
    6. 动画事件
      答：动画事件是指在动画效果开始、结束或中断时触发的事件，如animationstart、animationend和animationcancel。这些事件可以用于执行特定的JavaScript代码，以响应动画效果。
    7. 过渡和动画的区别
      答：
        - 过渡：用于在元素样式变化时创建平滑的动画效果，通常用于简单的样式变化，如颜色、位置等。
        - 动画：用于创建复杂的动画效果，可以定义多个关键帧，支持更丰富的动画效果和控制。
        - 过渡是单一属性变化的平滑过渡，而动画可以包含多个属性变化和关键帧。
  ## 渐进增强和优雅降级
    1. 渐进增强的概念
      答：渐进增强是一种Web开发策略，首先构建一个基本的、功能完整的Web应用，然后逐步添加高级功能和样式，以确保在不同浏览器和设备上都能正常工作。
    2. 优雅降级的概念
      答：优雅降级是一种Web开发策略，首先构建一个功能丰富的Web应用，然后确保在较旧或不支持新技术的浏览器中仍能提供基本功能和可用性。
    3. 渐进增强和优雅降级的区别
      答：渐进增强强调从基础开始构建，逐步添加功能，而优雅降级强调从完整功能开始，确保在较旧浏览器中仍能提供基本体验。渐进增强更注重可访问性和兼容性，而优雅降级更注重用户体验。
    4. 写法的不同
      答：渐进增强通常使用HTML5和CSS3等新技术，确保基本功能在所有浏览器中可用，然后添加JavaScript增强功能。而优雅降级则从完整的功能开始，使用JavaScript和CSS来提供更丰富的体验，同时确保在较旧浏览器中仍能正常工作。
  ## CSS3变形
    1. CSS3变形的概念
      答：CSS3变形是指使用transform属性对元素进行旋转、缩放、倾斜和平移等变形操作。它可以创建丰富的视觉效果和动画。
    2. CSS3变形的语法
      答：CSS3变形的基本语法为：
        ```css
        transform: transform-function;
        ```
        其中，transform-function可以是rotate、scale、skew、translate等。
    3. CSS3变形的应用场景
      答：CSS3变形常用于创建动画效果、交互效果和视觉效果，如旋转按钮、缩放图片、倾斜文本等。
    4. CSS3变形的注意事项
      答：
        - 变形会影响元素的布局和定位，需要谨慎使用。
        - 在某些情况下，可能会影响浏览器渲染性能，需优化使用。
        - 需要考虑浏览器兼容性，确保在不同浏览器中正常工作。
    5. CSS3变形的兼容性
      答：CSS3变形在现代浏览器中得到广泛支持，但在较旧的浏览器中可能不完全支持。开发者可以使用前缀（如-webkit-、-moz-等）来提高兼容性，同时使用特性检测（如Modernizr）来判断浏览器是否支持特定的变形功能。
  ## 渐进式渲染
    1. 渐进式渲染的概念
      答：渐进式渲染是一种Web开发策略，通过逐步加载和渲染页面内容，提高页面加载速度和用户体验。它可以在页面加载时先显示基本内容，然后逐步加载和渲染其他资源。
    2. 渐进式渲染的实现方式
      答：渐进式渲染可以通过以下方式实现：
        - 骨架屏技术，先显示页面的骨架结构，然后加载实际内容。
        - 使用懒加载技术，延迟加载非关键资源（如图片、视频等）。
        - 使用异步加载JavaScript和CSS文件，避免阻塞页面渲染。
        - 优化资源大小和格式，减少HTTP请求和加载时间。
        - 使用服务器端渲染（SSR）或静态站点生成（SSG）来提高初始加载速度。
    3. 渐进式渲染的优点
      答：
        - 提高页面加载速度，减少用户等待时间。
        - 改善用户体验，使用户能够更快地访问和交互页面内容。
        - 减少服务器负载，提高性能和可扩展性。
  ## CSS渲染性能优化
    1. id选择器性能更好
    2. 避免深层次的选择器
    3. 不用属性选择器
    4. 浏览器前缀前置
    5. 用缩写、0不写单位
    6. css优先于js
    7. csslint
    8. 不用@import
    9. 避免过分重排
  ## 重排和重绘
    1. 重排的概念
      答：重排（Reflow）是指浏览器重新计算元素的几何属性（如位置、大小等），通常发生在元素的尺寸、位置或内容发生变化时。
    2. 重绘的概念
      答：重绘（Repaint）是指浏览器重新渲染元素的外观，但不涉及几何属性的变化。通常发生在元素的颜色、背景等样式发生变化时。
    3. 重排和重绘的区别
      答：重排会导致浏览器重新计算元素的位置和大小，而重绘只会重新渲染元素的外观。重排比重绘更耗费性能，因为它涉及到布局计算。
    4. 重排和重绘的优化方法
      答：
        - 减少DOM操作，批量修改DOM以减少重排次数。
        - 使用CSS类切换而不是直接修改样式，以减少重排。
        - 使用文档片段（DocumentFragment）进行批量插入，避免多次重排。
        - 避免频繁读取布局属性（如offsetWidth、clientHeight等），因为这会触发浏览器强制重排。
        - 使用CSS3变形和过渡来实现动画效果，减少对布局的影响。
    5. 重排和重绘的性能影响
      答：重排和重绘会影响浏览器的渲染性能，频繁的重排和重绘会导致页面卡顿和响应迟钝。优化重排和重绘可以提高页面性能和用户体验。
    6. 重排和重绘的触发条件
      答：重排通常在以下情况下触发：
        - 元素的尺寸或位置发生变化（如添加、删除、修改元素）。
        - 页面结构发生变化（如插入或删除节点）。
        - CSS样式发生变化（如修改宽度、高度、边距等）。
      重绘通常在以下情况下触发：
        - 元素的颜色、背景、字体等样式发生变化。
        - 元素的可见性发生变化（如显示或隐藏元素）。
        - 元素的内容发生变化，但不影响其几何属性。
  ## 层叠上下文
    1. 层叠上下文的概念
      答：层叠上下文（Stacking Context）是CSS中的一个概念，用于控制元素在三维空间中的堆叠顺序。每个层叠上下文都是一个独立的渲染层，元素在该层内按照特定规则进行堆叠。
    2. 层叠上下文的触发条件
      答：触发层叠上下文的条件包括：
        - 根元素（html、body）
        - 绝对定位元素（positi330+=110935on为absolute或fixed，z-index不为auto）
        - 相对定位元素（position为relative，z-index不为auto）
        - flex容器（display为flex或inline-flex，z-index不为auto）
        - grid容器（display为grid或inline-grid，z-index不为auto）
        - opacity小于1
        - transform属性应用了非none值
    3. 层叠上下文的作用
      答：层叠上下文可以控制元素在堆叠顺序中的位置，使得某些元素可以覆盖其他元素。它有助于解决复杂的布局问题，如模态框、弹出菜单等。
    4. 层叠上下文的应用场景
      答：层叠上下文常用于创建复杂的布局和交互效果，如模态框、工具提示、下拉菜单等，以确保这些元素在视觉上正确地覆盖其他内容。
  ## CSS3 遮罩
    答：CSS3 遮罩（Mask）是一种用于控制元素可见区域的技术，可以实现复杂的形状和透明效果。通过使用遮罩，可以隐藏元素的部分区域，显示出底层内容或背景。
    1. 常见属性
      ```css
      mask: mask-image;
      mask-mode: alpha;
      mask-repeat: no-repeat;
      mask-position: center;
      mask-size: cover;
      mask-clip: content-box;
      mask-origin: content-box;
      mask-composite: add;
      ```
# JavaScript
  ## 作用域
      1. 作用域的概念
        答：作用域是指变量、函数等标识符的可访问范围。JavaScript中有全局作用域和局部作用域。
      2. 全局作用域和局部作用域
        答：
          - 全局作用域：在整个脚本中都可访问的变量和函数。
          - 函数作用域：函数内部的作用域，函数外部无法访问。
          - 块级作用域：使用let、const等关键字定义的变量，只在块级作用域内有效。
      3. 闭包的概念
        答：闭包是指一个函数可以访问其外部函数的变量，即使外部函数已经执行完毕。闭包可以用于数据封装和私有变量。
      4. 闭包的应用场景
        答：闭包常用于创建私有变量、模拟私有方法、实现模块化编程等。
      5. 闭包的优缺点
        答：
          - 优点：可以封装数据，避免全局污染，提供更好的代码组织。
          - 缺点：可能导致内存泄漏，过度使用会影响性能。
      6. 闭包的实现方式
        答：闭包可以通过以下方式实现：
          - 在函数内部定义函数，并将其作为返回值返回。
          - 使用立即执行函数表达式（IIFE）创建私有作用域。
          - 利用块级作用域（如let、const）创建闭包。
  ## let、var、const
    1. let、var、const的区别
      答：
        - var：函数作用域或全局作用域，可以重复声明，提升到函数或全局顶部。
        - let：块级作用域，不能重复声明，不提升。
        - const：块级作用域，不能重复声明，必须初始化，值不可变（但对象属性可变）。
    2. let、var、const的使用场景
      答：
        - var：适用于需要函数作用域的变量，但不推荐使用。
        - let：适用于需要块级作用域的变量，如循环计数器等。
        - const：适用于需要常量值的变量，如配置项等。
    3. let、var、const的提升
      答：
        - var会提升到函数或全局顶部，可以在声明之前使用，但值为undefined。
        - let和const不会提升，必须在声明之后使用，否则会抛出错误。
    4. let、var、const的作用域
      答：
        - var的作用域是函数作用域或全局作用域。
        - let和const的作用域是块级作用域，即在花括号内有效。
  ## JS的数据类型
    答：JavaScript中的数据类型分为两类：基本数据类型和引用数据类型。
    1. 基本数据类型
      答：基本数据类型包括：
        - Number：数字类型，表示整数或浮点数。
        - String：字符串类型，用于表示文本。
        - Boolean：布尔类型，表示真（true）或假（false）。
        - Undefined：未定义类型，表示变量未赋值。
        - Null：空类型，表示无值。
        - Symbol：符号类型，用于创建唯一的标识符（ES6引入）。
        - BigInt：大整数类型，用于表示大于2^53-1的整数（ES11引入）。
    2. 引用数据类型
      答：引用数据类型包括：
        - Object：对象类型，用于存储键值对。
        - Array：数组类型，特殊的对象，用于存储有序的元素集合。
        - Function：函数类型，特殊的对象，用于定义可执行的代码块。
        - Date：日期类型，用于处理日期和时间。
        - RegExp：正则表达式类型，用于模式匹配和文本处理。
    3. 数据类型的判断
      答：可以使用typeof运算符判断基本数据类型，使用instanceof运算符判断引用数据类型。
        - typeof：返回值为字符串，表示变量的数据类型，如typeof 123 返回 "number"。
        - instanceof：用于判断对象是否是某个构造函数的实例，如[] instanceof Array 返回 true。
        - Object.prototype.toString.call()：可以更准确地判断数据类型，如Object.prototype.toString.call([]) 返回 "[object Array]"。
        - Array.isArray()：用于判断一个对象是否是数组，如Array.isArray([]) 返回 true。
        - Number.isNaN()：用于判断一个值是否是NaN（非数字），如Number.isNaN(NaN) 返回 true。
  ## JS的类型转换
    答：JavaScript中的类型转换分为隐式转换和显式转换。
    1. 隐式转换
      答：隐式转换是指JavaScript在需要时自动将一种数据类型转换为另一种数据类型，如字符串与数字的相加。
        - 字符串与数字相加时，数字会被转换为字符串。
        - 布尔值与其他类型进行运算时，布尔值会被转换为数字（true为1，false为0）。
        - 对象与基本类型进行运算时，对象会被转换为原始值。
    2. 显式转换
      答：显式转换是指开发者主动将一种数据类型转换为另一种数据类型，常见的显式转换方法包括：
        - String()：将其他类型转换为字符串，如String(123) 返回 "123"。
        - Number()：将其他类型转换为数字，如Number("123") 返回 123。
        - Boolean()：将其他类型转换为布尔值，如Boolean(0) 返回 false。
        - parseInt()：将字符串转换为整数，如parseInt("123px") 返回 123。
        - parseFloat()：将字符串转换为浮点数，如parseFloat("123.45px") 返回 123.45。
        - JSON.parse()：将JSON字符串转换为JavaScript对象，如JSON.parse('{"name":"John"}') 返回 {name: "John"}。
        - JSON.stringify()：将JavaScript对象转换为JSON字符串，如JSON.stringify({name: "John"}) 返回 '{"name":"John"}'。
    3. 类型转换的注意事项
      答：
        - 在进行隐式转换时，可能会导致意想不到的结果，如字符串与数字相加时，数字会被转换为字符串。
        - 在进行显式转换时，需要确保转换的值是有效的，否则可能会导致错误或NaN。
        - 使用严格等于（===）和不等于（!==）运算符可以避免隐式类型转换带来的问题。
        - 注意NaN的特殊性，NaN与任何值比较都返回false，包括自身。

  ## JS的包装类型
    答：JavaScript中的包装类型是指将基本数据类型包装为对象，以便提供更多的方法和属性。常见的包装类型包括：
    1. Number对象
      答：Number对象用于包装数字类型，提供了许多方法，如toFixed()、toExponential()等。
    2. String对象
      答：String对象用于包装字符串类型，提供了许多方法，如charAt()、substring()、toUpperCase()等。
    3. Boolean对象
      答：Boolean对象用于包装布尔类型，提供了toString()方法。
    4. Symbol对象
      答：Symbol对象用于创建唯一的标识符，不能被直接转换为字符串或数字。
    5. BigInt对象
      答：BigInt对象用于表示大整数，可以通过BigInt()函数创建。
    6. 包装类型的使用场景
      答：包装类型常用于需要调用基本数据类型的方法时，如字符串操作、数字格式化等。但在大多数情况下，直接使用基本数据类型更为高效。
    注意：自动装箱和拆箱，自动装箱的包装对象会在需要时自动创建，而拆箱则是将包装对象转换回基本数据类型，不会影响下面代码中的基本数据类型。
  ## JS的运算符
    答：JavaScript中的运算符分为以下几类：
    1. 算术运算符
      答：用于进行数学运算，如加法（+）、减法（-）、乘法（*）、除法（/）、取余（%）等。
    2. 比较运算符
      答：用于比较两个值，如等于（==）、不等于（!=）、严格等于（===）、严格不等于（!==）、大于（>）、小于（<）、大于等于（>=）、小于等于（<=）等。
    3. 逻辑运算符
      答：用于进行逻辑运算，如与（&&）、或（||）、非（!）等。
    4. 位运算符
      答：用于对整数的二进制位进行操作，如按位与（&）、按位或（|）、按位异或（^）、左移（<<）、右移（>>）和无符号右移（>>>）等。
    5. 赋值运算符
      答：用于给变量赋值，如赋值（=）、加赋值（+=）、减赋值（-=）、乘赋值（*=）、除赋值 (/=)、取余赋值 (%=) 等。
    6. 条件（三元）运算符
      答：用于根据条件表达式返回不同的值，如 condition ? expr1 : expr2。
    7. typeof 运算符
      答：用于判断变量的数据类型，如 typeof variable 返回 "number"、"string"、"boolean" 等。
    8. instanceof 运算符
      答：用于判断对象是否是某个构造函数的实例，如 object instanceof Constructor 返回 true 或 false。
    9. delete 运算符
      答：用于删除对象的属性，如 delete object.property 删除对象的指定属性。
    10. void 运算符
      答：用于执行一个表达式并返回 undefined，如 void expression。
    11. in 运算符
      答：用于检查对象是否具有指定的属性，如 "property" in object 返回 true 或 false。
    12. 逗号运算符
      答：用于在一个表达式中执行多个操作，并返回最后一个操作的结果，如 (expr1, expr2) 返回 expr2 的值。
    13. 扩展运算符
      答：用于展开数组或对象，如 [...array] 将数组展开为单独的元素，{...object} 将对象的属性展开为新的对象。
    14. 其他运算符
      答：还有一些其他运算符，如解构赋值（const {a, b} = obj;）、可选链运算符（obj?.property）等。
    15. ?? 空值合并运算符
      答：用于返回第一个非空值，如 a ?? b，当 a 不为 null 或 undefined 时返回 a，否则返回 b。
    注意 Object.is() 方法可以用于比较两个值是否严格相等，类似于 ===，但在处理 NaN 和 -0 与 +0 时有所不同。
  ## 循环遍历的方法
    答：JavaScript中常用的循环遍历方法包括：
    1. for 循环
      答：用于按索引遍历数组或对象属性。
      ```javascript
      for (let i = 0; i < array.length; i++) {
        console.log(array[i]);
      }
      ```
    2. for...in 循环
      答：用于遍历对象的可枚举属性。
      ```javascript
      for (let key in object) {
        console.log(key, object[key]);
      }
      ```
    3. for...of 循环
      答：用于遍历数组、字符串、Map、Set等可迭代对象。
      ```javascript
      for (let value of array) {
        console.log(value);
      }
      ```
    4. Array.forEach() 方法
      答：用于对数组的每个元素执行指定的函数。
      ```javascript
      array.forEach((value, index) => {
        console.log(index, value);
      });
      ```
    5. Array.map() 方法
      答：用于对数组的每个元素执行指定的函数，并返回一个新数组。
      ```javascript
      const newArray = array.map((value, index) => {
        return value * 2; // 返回新数组的元素
      });
      ```
    6. Array.filter() 方法
      答：用于过滤数组的元素，返回一个新数组，其中包含满足条件的元素。
      ```javascript
      const filteredArray = array.filter((value) => {
        return value > 10; // 返回大于10的元素
      });
      ```
    7. Array.reduce() 方法
      答：用于对数组的每个元素执行指定的函数，并返回一个单一的值（累加器）。
      ```javascript
      const sum = array.reduce((accumulator, value) => {
        return accumulator + value; // 累加数组元素
      }, 0); // 初始值为0
      ```
    8. Array.some() 方法
      答：用于检查数组中是否至少有一个元素满足指定条件，返回布尔值。
      ```javascript
      const hasEven = array.some((value) => {
        return value % 2 === 0; // 检查是否有偶数
      });
      ```
    9. Array.every() 方法
      答：用于检查数组中的所有元素是否满足指定条件，返回布尔值。
      ```javascript
      const allPositive = array.every((value) => {
        return value > 0; // 检查是否所有元素都大于0
      });
      ```
    10. Array.find() 方法
      答：用于查找数组中第一个满足指定条件的元素，返回该元素或undefined。
      ```javascript
      const firstEven = array.find((value) => {
        return value % 2 === 0; // 查找第一个偶数
      });
      ```
    11. Array.findIndex() 方法
      答：用于查找数组中第一个满足指定条件的元素的索引，返回该索引或-1。
      ```javascript
      const index = array.findIndex((value) => {
        return value > 10; // 查找第一个大于10的元素的索引
      });
      ```
    12. for await...of 循环
      答：用于异步迭代可迭代对象（如异步生成器）。
      ```javascript
      async function asyncIterator() {
        for await (let value of asyncIterable) {
          console.log(value);
        }
      }
      ```
    13. while 循环
      答：用于在满足条件时重复执行代码块。
      ```javascript
      let i = 0;
      while (i < array.length) {
        console.log(array[i]);
        i++;
      }
      ```
    14. do...while 循环
      答：与while循环类似，但至少执行一次代码块。
      ```javascript
      let i = 0;
      do {
        console.log(array[i]);
        i++;
      } while (i < array.length);
      ```
  ## JS原型和原型链
    1. 原型的概念
      答：原型是JavaScript中实现继承和共享属性的方法。每个对象都有一个原型对象，可以通过__proto__属性访问。
    2. 原型链的概念
      答：原型链是指通过对象的原型属性形成的一条链式结构，用于查找对象的属性和方法。当访问一个对象的属性时，JavaScript会沿着原型链查找，直到找到该属性或到达Object.prototype。
    3. 原型和实例的关系
      答：实例对象可以访问其构造函数的原型对象上的属性和方法。通过原型，可以实现属性和方法的共享，从而节省内存。
    4. 原型链的作用
      答：原型链用于实现继承，使得子类可以访问父类的方法和属性。它还允许多个实例共享相同的方法，从而提高性能。
    5. 原型链的性能问题
      答：过长的原型链可能导致性能问题，因为每次访问属性时都需要沿着原型链查找。为了提高性能，可以使用直接引用或缓存常用属性。
    6. 原型链的实现方式
      答：原型链可以通过以下方式实现：
        - 使用构造函数创建对象，并将方法添加到构造函数的prototype属性上。
        - 使用Object.create()方法创建一个新对象，并指定其原型。
        - 使用class语法定义类，类的原型方法可以通过this访问。
    7. 原型链的注意事项
      答：
        - 修改原型对象会影响所有实例，因此需要谨慎修改。
        - 在访问属性时，如果属性在实例上不存在，JavaScript会沿着原型链查找，直到找到或到达Object.prototype。
        - 使用hasOwnProperty()方法可以判断属性是否为实例自身的属性，而不是从原型链继承的属性。
        - 使用Object.getPrototypeOf()方法可以获取对象的原型。
    8. 三角关系
      答：
      - 在JavaScript中，原型链形成了一个三角关系：对象 -> 原型 -> 原型的原型。每个对象都有一个原型，而原型又可以有自己的原型，这样形成了一个链式结构。
      -
      ```javascript
      function Person(name) {
        this.name = name;
      }
      Person.prototype.greet = function() {
        console.log(`Hello, my name is ${this.name}`);
      };
      const person = new Person('John');
      person.greet(); // 输出 "Hello, my name is John"
      console.log(person.__proto__ === Person.prototype); // 输出 true
      console.log(Person.prototype.__proto__ === Object.prototype); // 输出 true
      console.log(Object.prototype.__proto__); // 输出 null
      ```
    9. 普通对象和构造器对象
      答：普通对象是通过对象字面量或Object.create()等方式创建的对象，而构造器对象是通过构造函数创建的对象。构造器对象的原型链指向构造函数的prototype属性。
        - 只有构造器对象才有prototype属性，普通对象没有。
        - 普通对象的原型是Object.prototype，而构造器对象的原型是构造函数的prototype属性。
        - 无论是普通对象还是构造器对象，最终的constructor指向Function.prototype
        - Function的constructor指向自身。
        - Object这个构造函数的prototype属性指向Object.prototype，而Object.prototype的constructor指向Object。
        - Object实例化的对像的原型对象是Object.prototype,其他构造函数实例化的对象的原型对象是对应构造函数的prototype属性，再向上才是Object.prototype。
    10. 原型链的应用
      答：原型链可以用于实现继承、共享方法和属性、动态添加方法等。通过原型链，可以创建更灵活和可扩展的对象模型。
        - 继承：子类可以通过原型链访问父类的方法和属性。
        - 共享方法：多个实例可以共享同一个方法，节省内存，对于属性来说，所有对象独有一份，但是部分方法是共享的，可以把方法放在原型上，这样所有实例都可以访问同一个方法。
        - 动态添加方法：可以在运行时向原型添加新方法，使得所有实例都能访问。
    11. 原型相关的方法
      答：JavaScript提供了一些方法来操作原型链：
        - Object.getPrototypeOf(obj)：获取对象的原型。
        - Object.setPrototypeOf(obj, prototype)：设置对象的原型。
        - Object.create(prototype)：创建一个新对象，并指定其原型。
        - Object.prototype.hasOwnProperty(prop)：判断对象是否具有指定属性（不包括从原型链继承的属性）。
        - Object.prototype.isPrototypeOf(obj)：判断当前对象是否在指定对象的原型链上。

  ## 创建对象
    1. 使用对象字面量
      答：使用花括号{}创建一个对象。
      ```javascript
      const obj = { key: 'value' };
      ```
    2. 使用构造函数
      答：定义一个函数，并使用new关键字创建对象实例。
      ```javascript
      function Person(name, age) {
        this.name = name;
        this.age = age;
      }
      const person = new Person('John', 30);
      ```
    3. 使用Object.create()
      答：使用Object.create()方法创建一个新对象，并指定其原型。
      ```javascript
      const proto = { greet: function() { console.log('Hello'); } };
      const obj = Object.create(proto);
      obj.greet(); // 输出 "Hello"
      ```
    4. 使用class语法
      答：使用class关键字定义一个类，并使用new关键字创建对象实例。
      ```javascript
      class Person {
        constructor(name, age) {
          this.name = name;
          this.age = age;
        }
        greet() {
          console.log(`Hello, my name is ${this.name}`);
        }
      }
      const person = new Person('John', 30);
      person.greet(); // 输出 "Hello, my name is John"
      ```
    5. 使用工厂函数
      答：定义一个函数，返回一个新对象。
      ```javascript
      function createPerson(name, age) {
        return {
          name: name,
          age: age,
          greet: function() {
            console.log(`Hello, my name is ${this.name}`);
          }
        };
      }
      const person = createPerson('John', 30);
      person.greet(); // 输出 "Hello, my name is John"
      ```
    6. 使用JSON.parse()
      答：将JSON字符串解析为JavaScript对象。
      ```javascript
      const jsonString = '{"name": "John", "age": 30}';
      const obj = JSON.parse(jsonString);
      console.log(obj.name); // 输出 "John"
      ```
    7. 使用Object.assign()
      答：将一个或多个源对象的属性复制到目标对象。
      ```javascript
      const target = {};
      const source = { name: 'John', age: 30 };
      Object.assign(target, source);
      console.log(target); // 输出 { name: 'John', age: 30 }
      ```
    8. 使用Object.fromEntries()
      答：将键值对数组转换为对象。
      ```javascript
      const entries = [['name', 'John'], ['age', 30]];
      const obj = Object.fromEntries(entries);
      console.log(obj); // 输出 { name: 'John', age: 30 }
      ```
  ## new 关键字
    答：用于创建对象实例并调用构造函数。
    1. new 所经历的步骤
      答：使用new关键字创建对象时，经历以下步骤：
        - 创建一个新对象。
        - 将新对象的__proto__属性指向构造函数的prototype属性。
        - 执行构造函数，并将this绑定到新对象上。
        - 如果构造函数返回一个对象，则返回该对象；否则返回新创建的对象。
      ```javascript
      function Person(name) {
        this.name = name;
      }
      const person = new Person('John');
    
      const obj = {}
      obj.__proto__ = Person.prototype; // 设置原型链
      this->obj; // 将this绑定到新对象上
      Person.call(obj, 'John'); // 执行构造函数
      return obj; // 返回新创建的对象
      ```
  ## 执行栈和执行上下文
    1. js中的执行环境和执行上下文
      - 全局环境、函数环境、eval环境
      - 全局执行上下文、函数执行上下文、eval执行上下文
    2. 什么是执行栈和执行上下文，他们有什么关系
      答：
        1. 执行栈（Call Stack）是一个数据结构，用于管理函数调用的顺序。它是一个后进先出（LIFO）的结构，当一个函数被调用时，它会被压入栈顶，当函数执行完毕时，它会从栈顶弹出。
        2. 执行上下文（Execution Context）是一个抽象概念，表示代码执行时的环境。每当函数被调用时，都会创建一个新的执行上下文。执行上下文包含了变量、函数、this指针等信息。
        3. 执行栈和执行上下文的关系是：每当一个函数被调用时，都会创建一个新的执行上下文，并将其压入执行栈。当函数执行完毕时，对应的执行上下文会从栈顶弹出。
    
    3. 执行上下文的生命周期
      1. 创建阶段
        - 创建一个新的执行上下文对象。
        - 确定变量对象（Variable Object），包括函数声明、变量声明和参数。
        - 确定作用域链（Scope Chain），用于查找变量和函数。
        - 确定this指针的值。
        注意：在创建阶段，变量和函数声明会被提升，但赋值不会，函数声明会被提升到顶部
      2. 执行阶段
        - 执行代码，初始化变量和函数。
        - 处理函数调用，将新的执行上下文压入执行栈。
      3. 销毁阶段
        - 当函数执行完毕，执行上下文从执行栈中弹出。
        - 如果没有其他引用指向该执行上下文，它将被垃圾回收机制回收。
  ## 作用域和作用域链
    1. 作用域（Scope）
      答：作用域是指变量、函数等标识符的可访问范围
      - 全局作用域：在整个脚本中都可访问的变量和函数。
      - 函数作用域：函数内部的作用域，函数外部无法访问。
      - 块级作用域：使用let、const等关键字定义的变量，只在块级作用域内有效。
    2. 作用域链（Scope Chain）
      答：作用域链是由多个作用域组成的链式结构，用于查找变量和函数。当访问一个变量时，JavaScript会沿着作用域链查找，直到找到该变量或到达全局作用域。
    3. 静态作用域
      答：JavaScript使用静态作用域（Lexical Scope），即变量的作用域在代码编写时就已经确定，而不是在运行时动态决定。函数的作用域由其定义的位置决定，而****不是调用的位置**。
      - 例如：
      ```javascript
      function outer() {
        const x = 10;
        function inner() {
          console.log(x); // 访问外部函数的变量
        }
        inner();
      }
      outer(); // 输出 10
      ```
  ## js中的this
    1. this的概念
      答：this是一个关键字，指向当前执行上下文中的对象。它的值取决于函数的调用方式。
    2. this的指向规则
      答：
        - 全局作用域：在全局作用域中，this指向全局对象（浏览器中为window）。
        - 函数调用：在函数调用时，this指向调用该函数的对象。
        - 方法调用：在对象的方法中，this指向该对象。
        - 构造函数调用：在使用new关键字调用构造函数时，this指向新创建的实例对象。
        - 箭头函数：箭头函数没有自己的this，它会继承外部函数的this。
        - 显式绑定：使用call、apply或bind方法可以显式地设置this的值。
    3. this的应用场景
      答：this常用于访问对象的属性和方法，如事件处理、回调函数等。通过正确理解this，可以避免常见的错误，如在回调函数中丢失上下文。
    4. this的注意事项
      答：
        - 在事件处理函数中，this通常指向触发事件的元素。
        - 在箭头函数中，this不会被重新绑定，而是继承自外部作用域。
        - 使用bind()方法可以创建一个新的函数，并将this绑定到指定对象上。
    5. this的例子
      答：
      ```javascript
      // 全局作用域
      console.log(this); // 在浏览器中输出 window 对象
    
      // 函数调用
      function showThis() {
        console.log(this);
      }
      showThis(); // 输出 window 对象
    
      // 方法调用
      const obj = {
        name: 'John',
        greet: function() {
          console.log(`Hello, my name is ${this.name}`);
        }
      };
      obj.greet(); // 输出 "Hello, my name is John"
    
      // 构造函数调用
      function Person(name) {
        this.name = name;
      }
      const person = new Person('Alice');
      console.log(person.name); // 输出 "Alice"
    
      // 箭头函数
      const arrowFunc = () => {
        console.log(this);
      };
      arrowFunc(); // 输出全局对象（在浏览器中为 window）
    
      // 显式绑定
      function showName() {
        console.log(this.name);
      }
      const user = { name: 'Bob' };
      showName.call(user); // 输出 "Bob"
      showName.apply(user); // 输出 "Bob"
      const boundFunc = showName.bind(user);
      boundFunc(); // 输出 "Bob"
    
      // DOM绑定事件 this 指向触发事件的元素
      const button = document.querySelector('button');
      button.addEventListener('click', function() {
        console.log(this); // 输出触发事件的按钮元素
      });
      ```
  ## 垃圾回收和内存泄漏
    1. 垃圾回收（Garbage Collection）
      答：垃圾回收是JavaScript引擎自动管理内存的机制，用于释放不再使用的内存空间。它通过标记和清除算法来识别和回收不再需要的对象。
    2. 垃圾回收的工作原理
      答：垃圾回收通常使用以下两种算法：
        - 标记清除（Mark-and-Sweep）：标记所有可达的对象，然后清除未被标记的对象。
        - 引用计数（Reference Counting）：跟踪对象的引用计数，当引用计数为0时，回收该对象。
      注意：现代JavaScript引擎通常使用标记清除算法。
    3. 内存泄漏（Memory Leak）
      答：内存泄漏是指程序中未释放的内存空间，导致内存使用量不断增加。常见的内存泄漏原因包括：
        - 全局变量：未清理的全局变量会一直占用内存。
        - 闭包：闭包持有外部函数的引用，可能导致无法释放内存。
        - 事件监听器：未移除的事件监听器会导致对象无法被垃圾回收。
        - 循环引用：两个或多个对象互相引用，导致无法被垃圾回收。
    4. 如何避免内存泄漏
      答：可以通过以下方式避免内存泄漏：
        - 使用局部变量，避免全局变量的使用。
        - 在不需要时及时清理闭包和事件监听器。
        - 使用WeakMap和WeakSet来存储对象引用，这样可以避免循环引用导致的内存泄漏。
        - 定期检查和优化代码，确保没有未使用的对象或资源。
    5. 垃圾回收的触发时机
      答：垃圾回收通常在以下情况下触发：
        - 当内存使用量超过一定阈值时，JavaScript引擎会自动触发垃圾回收。
        - 当执行上下文结束时，相关的局部变量和对象可能会被回收。
        - 在浏览器中，当页面关闭或刷新时，所有相关的内存都会被释放。
      注意：垃圾回收是自动进行的，开发者无法直接控制其触发时机，但可以通过优化代码来减少内存使用。
  ## JS 闭包
    1. 闭包的概念
      答：闭包是指一个函数可以访问其外部作用域中的变量，即使外部函数已经执行完毕。闭包允许函数记住其创建时的作用域。
    2. 闭包的创建方式
      答：闭包通常通过以下方式创建：
        - 在函数内部定义另一个函数，并返回该函数。
        - 使用匿名函数或箭头函数来创建闭包。
      ```javascript
      function outer() {
        const outerVar = 'I am outside!';
        return function inner() {
          console.log(outerVar); // 访问外部变量
        };
      }
      const closureFunc = outer();
      closureFunc(); // 输出 "I am outside!"
      ```
    3. 闭包的应用场景
      答：闭包常用于以下场景：
        - 数据封装：可以将私有变量封装在闭包中，避免外部直接访问。
        - 函数工厂：可以创建具有特定行为的函数，如计数器、缓存等。
        - 事件处理：在事件处理函数中使用闭包，可以访问外部变量。
      ```javascript
      function createCounter() {
        let count = 0;
        return {
          increment: function() {
            count++;
            console.log(count);
          },
          decrement: function() {
            count--;
            console.log(count);
          }
        };
      }
      const counter = createCounter();
      counter.increment(); // 输出 1
      counter.increment(); // 输出 2
      counter.decrement(); // 输出 1
      ```
    4. 闭包的注意事项
      答：
        - 闭包会导致外部变量无法被垃圾回收，可能导致内存泄漏。
        - 使用闭包时要注意变量的作用域，避免意外修改外部变量。
        - 尽量避免在循环中创建闭包，以免产生意外的行为。
    5. 闭包的性能问题
      答：闭包可能会导致性能问题，因为它会增加内存使用和函数调用的开销。为了优化性能，可以：
        - 避免在循环中创建闭包。
        - 使用局部变量而不是全局变量。
        - 在不需要时及时清理闭包，避免内存泄漏。
      ```javascript
      for (let i = 0; i < 5; i++) {
        setTimeout(() => {
          console.log(i); // 输出 0, 1, 2, 3, 4
        }, 1000);
      }
      ```
  ## DOM 注册事件
    1. DOM事件的概念
      答：DOM事件是指用户与网页交互时触发的事件，如点击、键盘输入、鼠标移动等。JavaScript可以通过事件监听器来响应这些事件。
    2. 注册事件的方式
      答：
        - 使用addEventListener()方法注册事件监听器。
        - 使用onclick、onmouseover等属性直接注册事件处理函数。（只能注册一个事件处理函数，后注册的会覆盖前一个）
      ```javascript
      const button = document.querySelector('button');
      button.addEventListener('click', function() {
        console.log('Button clicked!');
      });
      ```
    3. 事件对象
      答：当事件被触发时，浏览器会创建一个事件对象，包含有关事件的信息，如类型、目标元素、鼠标位置等。可以在事件处理函数中访问该对象。
      ```javascript
      button.addEventListener('click', function(event) {
        console.log(event.type); // 输出 "click"
        console.log(event.target); // 输出触发事件的元素
      });
      ```
    4. 事件冒泡和捕获
      答：DOM事件有两种传播方式：冒泡和捕获。
        - 冒泡（Bubbling）：从目标元素开始，向上冒泡到父元素，直到document对象。
        - 捕获（Capturing）：从document对象开始，向下捕获到目标元素。
      可以通过addEventListener()方法的第三个参数来指定是否使用捕获模式。
      ```javascript
      button.addEventListener('click', function(event) {
        console.log('Button clicked!');
      }, true); // true表示使用捕获模式
      ```
    5. 移除事件监听器
      答：可以使用removeEventListener()方法移除已注册的事件监听器。需要确保传入的函数引用与注册时一致。
      ```javascript
      function handleClick(event) {
        console.log('Button clicked!');
      }
      button.addEventListener('click', handleClick);
      // 移除事件监听器
      button.removeEventListener('click', handleClick);
      ```
    6. 事件委托
      答：事件委托是指将事件监听器添加到父元素上，而不是每个子元素上。这样可以减少内存使用和提高性能，尤其是在动态添加或删除子元素时。
      ```javascript
      const list = document.querySelector('ul');
      list.addEventListener('click', function(event) {
        if (event.target.tagName === 'LI') {
          console.log('List item clicked:', event.target.textContent);
        }
      });
      ```
    7. 事件的默认行为
      答：某些事件有默认行为，如点击链接会跳转、提交表单会刷新页面等。
      1. 可以使用event.preventDefault()方法阻止默认行为。
        ```javascript
        const link = document.querySelector('a');
        link.addEventListener('click', function(event) {
          event.preventDefault(); // 阻止链接跳转
          console.log('Link clicked, but no navigation.');
          console.log(event.defaultPrevented); // 输出 true，表示默认行为已被阻止
        });
        ```
      2. 可以使用event.stopPropagation()方法阻止事件冒泡。
        ```javascript
        const button = document.querySelector('button');
        button.addEventListener('click', function(event) {
          event.stopPropagation(); // 阻止事件冒泡
          console.log('Button clicked, but no bubbling.');
        });
      const parent = document.querySelector('.parent');
      parent.addEventListener('click', function() {
        console.log('Parent clicked!');
      });
      ```
    8. 事件的this指向
      答：在事件处理函数中，this通常指向触发事件的元素。如果使用箭头函数，this会继承外部作用域的值。
      ```javascript
      button.addEventListener('click', function() {
        console.log(this); // 输出触发事件的按钮元素
      });
      const arrowButton = document.querySelector('.arrow-button');
      arrowButton.addEventListener('click', () => {
        console.log(this); // 输出全局对象（在浏览器中为 window）
      });
      ```
    9. 事件的节流和防抖
      答：节流和防抖是优化事件处理的技术。
        - 节流（Throttling）：限制事件处理函数的执行频率，如每隔一定时间执行一次。
        - 防抖（Debouncing）：在事件触发后，延迟执行处理函数，直到事件停止触发一段时间后才执行。
      ```javascript
      // 节流示例
      function throttle(func, delay) {
        let lastTime = 0;
        return function(...args) {
          const now = Date.now();
          if (now - lastTime >= delay) {
            lastTime = now;
            func.apply(this, args);
          }
        };
      }
      window.addEventListener('resize', throttle(() => {
        console.log('Window resized!');
      }, 1000));
    
      // 防抖示例
      function debounce(func, delay) {
        let timeout;
        return function(...args) {
          clearTimeout(timeout);
          timeout = setTimeout(() => {
            func.apply(this, args);
          }, delay);
        };
      }
      window.addEventListener('scroll', debounce(() => {
        console.log('Window scrolled!');
      }, 500));
      ```
    10. 事件的生命周期
      答：事件的生命周期包括以下几个阶段：
        - 触发阶段：用户与页面交互触发事件。
        - 捕获阶段：事件从document对象向下传播到目标元素。
        - 目标阶段：事件到达目标元素，执行对应的事件处理函数。
        - 冒泡阶段：事件从目标元素向上冒泡到document对象。
      可以通过addEventListener()方法的第三个参数来控制是否使用捕获模式。
      ```javascript
      button.addEventListener('click', function(event) {
        console.log('Button clicked!');
      }, false); // false表示使用冒泡模式（默认）
      ```
  ## JS 递归
    1. 递归的概念
      答：递归是指函数直接或间接调用自身的编程技术。递归通常用于解决可以分解为更小子问题的问题。
    2. 递归的基本结构
      答：递归函数通常包含两个部分：
        - 基本情况（Base Case）：用于终止递归的条件。
        - 递归情况（Recursive Case）：函数调用自身以解决更小的子问题。
      ```javascript
      function factorial(n) {
        if (n === 0) {
          return 1; // 基本情况
        }
        return n * factorial(n - 1); // 递归情况
      }
      console.log(factorial(5)); // 输出 120
      ```
    3. 递归的应用场景
      答：递归常用于以下场景：
        - 数学计算：如阶乘、斐波那契数列等。
        - 数据结构遍历：如树、图等数据结构的遍历。
        - 分治算法：将问题分解为更小的子问题进行求解。
      ```javascript
      // 斐波那契数列
      function fibonacci(n) {
        if (n <= 1) {
          return n; // 基本情况
        }
        return fibonacci(n - 1) + fibonacci(n - 2); // 递归情况
      }
      console.log(fibonacci(6)); // 输出 8
      ```
    4. 递归的注意事项
      答：
        - 确保有基本情况以终止递归，避免无限循环。
        - 注意栈溢出问题，过深的递归可能导致浏览器崩溃或报错。
        - 在某些情况下，可以使用迭代方式替代递归，以提高性能和避免栈溢出。
      ```javascript
      function iterativeFibonacci(n) {
        let a = 0, b = 1;
        for (let i = 0; i < n; i++) {
          [a, b] = [b, a + b]; // 使用解构赋值交换变量
        }
        return a;
      }
      console.log(iterativeFibonacci(6)); // 输出 8
      ```
    5. 递归的性能问题
      答：递归可能导致性能问题，尤其是在处理大数据时。每次递归调用都会增加函数调用的开销，可能导致栈溢出。
        - 可以使用尾递归优化（Tail Call Optimization）来减少栈空间的使用，但JavaScript引擎对尾递归的支持有限。
        - 使用动态规划或记忆化技术可以提高递归算法的性能，避免重复计算。
      ```javascript
      // 记忆化斐波那契数列
      const memo = {};
      function memoizedFibonacci(n) {
        if (n in memo) {
          return memo[n]; // 返回已计算的结果
        }
        if (n <= 1) {
          return n; // 基本情况
        }
        memo[n] = memoizedFibonacci(n - 1) + memoizedFibonacci(n - 2); // 递归情况
        return memo[n];
      }
      console.log(memoizedFibonacci(6)); // 输出 8
      ```
  ## 属性描述符
    1. 属性描述符的概念
      答：属性描述符是一个对象，用于描述对象属性的特性，如可写性、可枚举性、可配置性等。JavaScript提供了Object.defineProperty()方法来定义属性描述符。
    2. 属性描述符的类型
      答：属性描述符分为两种类型：
        - 数据属性描述符（Data Property Descriptor）：包含值和可写性。
        - 访问器属性描述符（Accessor Property Descriptor）：包含getter和setter函数。
      ```javascript
      const obj = {};
      Object.defineProperty(obj, 'name', {
        value: 'John',
        writable: true,
        enumerable: true,
        configurable: true
      });
      console.log(obj.name); // 输出 "John"
      ```
    3. 数据属性描述符的特性
      答：数据属性描述符包含以下特性：
        - value：属性的值。
        - writable：布尔值，表示属性是否可写。
        - enumerable：布尔值，表示属性是否可枚举。
        - configurable：布尔值，表示属性是否可以被删除或修改。
      ```javascript
      Object.defineProperty(obj, 'age', {
        value: 30,
        writable: false, // 不可写
        enumerable: true,
        configurable: false // 不可删除或修改
      });
      console.log(obj.age); // 输出 30
      obj.age = 31; // 无效操作，age属性不可写
      console.log(obj.age); // 仍然输出 30
      ```
    4. 访问器属性描述符的特性
      答：访问器属性描述符包含以下特性：
        - get：一个函数，用于获取属性值。
        - set：一个函数，用于设置属性值。
        - enumerable：布尔值，表示属性是否可枚举。（是否会被for/in和Object.keys()等方法遍历）
        - configurable：布尔值，表示该对象的属性是否可以被删除或修改。
      ```javascript
      Object.defineProperty(obj, 'fullName', {
        get: function() {
          return `${this.name} Doe`;
        },
        set: function(value) {
          this.name = value.split(' ')[0];
        },
        enumerable: true,
        configurable: true
      });
      console.log(obj.fullName); // 输出 "John Doe"
      obj.fullName = 'Alice Smith';
      console.log(obj.name); // 输出 "Alice"
      ```
    5. 属性描述符的应用场景
      答：属性描述符常用于以下场景：
        - 定义只读属性：通过设置writable为false，可以创建只读属性。
        - 创建计算属性：使用getter和setter函数，可以创建动态计算的属性。
        - 控制属性的可见性：通过设置enumerable为false，可以隐藏属性，使其不出现在for...in循环中。
        - 定义不可配置的属性：通过设置configurable为false，可以防止属性被删除或修改。
      ```javascript
      Object.defineProperty(obj, 'hidden', {
        value: 'This is hidden',
        enumerable: false // 不可枚举
      });
      console.log(obj.hidden); // 输出 "This is hidden"
      for (const key in obj) {
        console.log(key); // 不会输出 "hidden"
      }
      ```
    6. 属性描述符的注意事项
      答：
        - 使用Object.defineProperty()定义属性时，如果属性已存在，则会覆盖原有的属性描述符。
        - 如果要修改现有属性的特性，需要将configurable设置为true，否则无法修改。
        - 访问器属性描述符不能同时包含value和writable特性，只能选择一种类型。
        - 属性描述符的默认值：如果未显式设置某个特性，默认为false（除value外）。
      ```javascript
      Object.defineProperty(obj, 'newProp', {
        value: 'New Property',
        writable: true // 可写
      });
      console.log(obj.newProp); // 输出 "New Property"
      obj.newProp = 'Updated Property';
      console.log(obj.newProp); // 输出 "Updated Property"
      ```
  ## Object 常用对象方法
    答：JavaScript的Object对象提供了一些常用的方法来操作对象，这些方法包括：
      1. Object.keys(obj)
        - 返回一个包含对象自身可枚举属性名的数组。
      2. Object.values(obj)
        - 返回一个包含对象自身可枚举属性值的数组。
      3. Object.entries(obj)
        - 返回一个包含对象自身可枚举属性键值对的数组，每个键值对是一个数组。
      4. Object.assign(target, ...sources)
        - 将一个或多个源对象的属性复制到目标对象，并返回目标对象。
      5. Object.freeze(obj)
        - 冻结对象，使其不可修改（不能添加、删除或修改属性）。
      6. Object.seal(obj)
        - 密封对象，使其不可添加新属性，但可以修改现有属性的值。
      7. Object.isFrozen(obj)
        - 检查对象是否被冻结，返回布尔值。
      8. Object.getOwnPropertyDescriptor(obj, prop)
        - 返回指定属性的属性描述符对象，包含该属性的特性（如value、writable、enumerable、configurable）。
      9. Object.defineProperty(obj, prop, descriptor)
        - 定义或修改对象的属性，并可以设置属性的特性（如value、writable、enumerable、configurable）。
      10. Object.defineProperties(obj, descriptors)
        - 定义或修改对象的多个属性，descriptors是一个包含多个属性描述符的对象。
      11. Object.getOwnPropertyNames(obj)
        - 返回一个包含对象自身所有属性名的数组，包括不可枚举属性。
      12. Object.getPrototypeOf(obj)
        - 返回对象的原型（即该对象的__proto__属性）。
      13. Object.setPrototypeOf(obj, prototype)
        - 设置对象的原型为指定的对象，并返回该对象。
      14. Object.create(proto, propertiesObject)
        - 创建一个新对象，使用指定的原型对象和可选的属性描述符。
      15. Object.fromEntries(iterable)
        - 将一个键值对的可迭代对象（如数组）转换为对象。
      16. Object.is(value1, value2)
        - 判断两个值是否严格相等，类似于===，但处理NaN和+0/-0的方式不同。
  ##  Array 常用方法
    答：JavaScript的Array对象提供了许多常用的方法来操作数组，这些方法包括：
      1. Array.isArray(value)
        - 检查给定的值是否为数组，返回布尔值。
      2. array.push(...items)
        - 向数组末尾添加一个或多个元素，并返回新数组的长度。
      3. array.pop()
        - 从数组末尾删除一个元素，并返回该元素。
      4. array.shift()
        - 从数组开头删除一个元素，并返回该元素。
      5. array.unshift(...items)
        - 向数组开头添加一个或多个元素，并返回新数组的长度。
      6. array.concat(...items)
        - 合并两个或多个数组，并返回新数组。
      7. array.slice(start, end)
        - 返回数组的一个浅拷贝，包含从start到end（不包括end）的元素。
      8. array.splice(start, deleteCount, ...items)
        - 从数组中添加或删除元素，返回被删除的元素。
      9. array.indexOf(searchElement, fromIndex)
        - 返回指定元素在数组中的第一个索引，如果未找到则返回-1。
      11. array.includes(searchElement, fromIndex)
        - 检查数组是否包含指定元素，返回布尔值。
      12. array.forEach(callback(currentValue, index, array), thisArg)
        - 对数组的每个元素执行一次提供的函数。
      13. array.map(callback(currentValue, index, array), thisArg)
        - 创建一个新数组，包含对原数组每个元素调用提供函数后的结果。
      14. array.filter(callback(currentValue, index, array), thisArg)
        - 创建一个新数组，包含所有通过测试的元素。
      15. array.reduce(callback(accumulator, currentValue, index, array), initialValue)
        - 对数组中的每个元素执行一次提供的函数，将其结果汇总为单个值。
      17. array.find(callback(currentValue, index, array), thisArg)
        - 返回数组中满足提供测试函数的第一个元素，如果没有找到则返回undefined。
      18. array.findIndex(callback(currentValue, index, array), thisArg)
        - 返回数组中满足提供测试函数的第一个元素的索引，如果没有找到则返回-1。
      19. array.some(callback(currentValue, index, array), thisArg)
        - 检查数组中是否至少有一个元素满足提供的测试函数，返回布尔值。
      20. array.every(callback(currentValue, index, array), thisArg)
        - 检查数组中是否所有元素都满足提供的测试函数，返回布尔值。
      21. array.sort(compareFunction)
        - 对数组元素进行排序，并返回排序后的数组。compareFunction用于定义排序顺序。
      22. array.reverse()
        - 反转数组中的元素顺序，并返回反转后的数组。
      23. array.join(separator)
        - 将数组的所有元素连接成一个字符串，使用指定的分隔符（默认为逗号）。
      24. array.toString()
        - 将数组转换为字符串，等同于array.join(',')。
      25. array.flat(depth)
        - 将多维数组扁平化为一维数组，depth指定扁平化的深度（默认为1）。
      28. array.fill(value, start, end)
        - 用指定的值填充数组的指定范围，返回修改后的数组。
  ## Reflect
    答：Reflect是一个内置对象，提供了一些方法来操作对象的属性和行为。它的主要目的是提供与Object对象相似的功能，但具有更一致的行为和更好的错误处理。
    1. Reflect.get(target, propertyKey, receiver)
      - 获取对象target上指定属性propertyKey的值，receiver用于处理getter函数中的this指向。
    2. Reflect.set(target, propertyKey, value, receiver)
      - 设置对象target上指定属性propertyKey的值为value，receiver用于处理setter函数中的this指向。
    3. Reflect.has(target, propertyKey)
      - 检查对象target是否具有指定属性propertyKey，返回布尔值。
    4. Reflect.deleteProperty(target, propertyKey)
      - 删除对象target上指定属性propertyKey，并返回布尔值表示删除是否成功。
    5. Reflect.apply(target, thisArgument, argumentsList)
      - 调用函数target，并将this指向thisArgument，传入参数argumentsList。
    6. Reflect.construct(target, argumentsList[, newTarget])
      - 使用new关键字调用构造函数target，并传入参数argumentsList，newTarget用于指定构造函数的原型。
    7. Reflect.defineProperty(target, propertyKey, attributes)
      - 定义或修改对象target上的属性propertyKey，使用attributes描述符。
    8. Reflect.getOwnPropertyDescriptor(target, propertyKey)
      - 返回对象target上指定属性propertyKey的属性描述符。
    9. Reflect.getPrototypeOf(target)
      - 返回对象target的原型（即__proto_  _）。
    10. Reflect.setPrototypeOf(target, prototype)
      - 设置对象target的原型为prototype，并返回布尔值表示设置是否成功。
    11. Reflect.isExtensible(target)
      - 检查对象target是否可扩展（即是否可以添加新属性），返回布尔值。
    12. Reflect.preventExtensions(target)
      - 防止对象target添加新属性，并返回布尔值表示操作是否成功。
    13. Reflect.ownKeys(target)
      - 返回对象target的所有自身属性键，包括不可枚举属性和Symbol属性。
  ## Proxy
    答：Proxy是一个内置对象，用于创建一个代理对象，以便在访问目标对象时可以自定义其行为。通过Proxy，可以拦截和修改对目标对象的基本操作，如属性访问、赋值、枚举、函数调用等。
    1. new Proxy(target, handler)
      - 创建一个新的代理对象，target是要代理的目标对象，handler是一个对象，用于定义代理的行为。
    2. handler.get(target, property, receiver)
      - 拦截对target对象属性的访问，property是要访问的属性名，receiver是用于处理getter函数中的this指向。
    3. handler.set(target, property, value, receiver)
      - 拦截对target对象属性的赋值，property是要赋值的属性名，value是要赋的值，receiver是用于处理setter函数中的this指向。
    4. handler.has(target, property)
      - 拦截对target对象属性的存在性检查，property是要检查的属性名。
    5. handler.deleteProperty(target, property)
      - 拦截对target对象属性的删除，property是要删除的属性名。
    6. handler.apply(target, thisArg, argumentsList)
      - 拦截对target函数的调用，thisArg是函数调用时的this指向，argumentsList是传入的参数列表。
    7. handler.construct(target, argumentsList, newTarget)
      - 拦截对target构造函数的调用，argumentsList是传入的参数列表，newTarget用于指定构造函数的原型。
  ## class 和 构造函数的区别
    答：JavaScript中的class和构造函数都是用于创建对象的方式，但它们有一些区别：
    1. 语法
      - class使用class关键字定义，具有更清晰的语法结构。
      - 构造函数使用function关键字定义，通常以 大写字母开头。
      ```javascript
      // class定义
      class Person {
        constructor(name) {
          this.name = name;
        }
        greet() {
          console.log(`Hello, my name is ${this.name}`);
        }
      }
    
      // 构造函数定义
      function PersonConstructor(name) {
        this.name = name;
      }
      PersonConstructor.prototype.greet = function() {
        console.log(`Hello, my name is ${this.name}`);
      };
      ```
    2. 原型链
      - class自动创建一个原型对象，并将方法添加到该原型上。
      - 构造函数需要手动将方法添加到原型上。
    3. 继承
      - class使用extends关键字进行继承，语法更简洁。
      - 构造函数使用Object.create()或call/apply来实现继承。
      ```javascript
      // class继承
      class Student extends Person {
        constructor(name, grade) {
          super(name); // 调用父类构造函数
          this.grade = grade;
        }
        study() {
          console.log(`${this.name} is studying.`);
        }
      }
    
      // 构造函数继承
      function StudentConstructor(name, grade) {
        PersonConstructor.call(this, name); // 调用父类构造函数
        this.grade = grade;
      }
      StudentConstructor.prototype = Object.create(PersonConstructor.prototype);
      StudentConstructor.prototype.constructor = StudentConstructor;
      StudentConstructor.prototype.study = function() {
        console.log(`${this.name} is studying.`);
      };
      ```
    4. 静态方法
      - class可以定义静态方法，使用static关键字。
      - 构造函数没有内置的静态方法语法，需要手动添加到构造函数上。
      ```javascript
      class MathUtils {
        static add(a, b) {
          return a + b;
        }
      }
    
      function MathUtilsConstructor() {}
      MathUtilsConstructor.add = function(a, b) {
        return a + b;
      };
      ```
    5. this指向
      - 在class中，this指向实例对象。
      - 在构造函数中，this指向新创建的对象。
      ```javascript
      const person = new Person('Alice');
      person.greet(); // 输出 "Hello, my name is Alice"
    
      const personConstructor = new PersonConstructor('Bob');
      personConstructor.greet(); // 输出 "Hello, my name is Bob"
      ```
    6. 可读性和可维护性
      - class语法更接近其他面向对象编程语言（如Java、C#），更易于理解和维护。
      - 构造函数语法较为传统，可能对新手不太友好。
    7. 兼容性
      - class是ES6引入的语法，较新版本的JavaScript支持。
      - 构造函数是JavaScript的传统语法，兼容性更好，支持更早版本的JavaScript。
    8. Babel的实现
      - Babel等编译工具可以将class语法转换为构造函数语法，以便在不支持ES6的环境中使用。
      - 这使得class语法可以在旧版本的浏览器或JavaScript引擎中运行。
      ```javascript
      // Babel转换后的代码示例
      var Person = function(name) {
        this.name = name;
      };
      Person.prototype.greet = function() {
        console.log(`Hello, my name is ${this.name}`);
      };
      ```
  ## 浮点数精度问题
    答：JavaScript中的浮点数使用IEEE 754标准表示，这可能导致精度问题，尤其是在进行数学运算时。常见的浮点数精度问题包括：
    1. 精度丢失
      - 由于二进制表示法的限制，一些十进制数无法精确表示，如0.1和0.2。
      - 例如，0.1 + 0.2 !== 0.3，实际结果为0.30000000000000004。
      ```javascript
      console.log(0.1 + 0.2); // 输出 0.30000000000000004
      ```
    2. 四舍五入误差
      - 在进行四舍五入操作时，可能会出现意外的结果。
      - 例如，Math.round(0.1 + 0.2) !== Math.round(0.3)。
      ```javascript
      console.log(Math.round(0.1 + 0.2)); // 输出 0
      console.log(Math.round(0.3)); // 输出 0
      ```
    3. 大数计算问题
      - 当处理非常大的或非常小的浮点数时，可能会出现精度问题。
      - 例如，1e20 + 1 !== 1e20，因为1在大数中被忽略了。
      ```javascript
      console.log(1e20 + 1); // 输出 1e20
      ```
    4. 使用整数代替浮点数
      - 为了避免浮点数精度问题，可以将所有数字转换为整数进行计算，然后再转换回浮点数。
      - 例如，将金额以分为单位存储和计算。
      ```javascript
      const price = 100; // 单位为分
      const tax = 5; // 单位为分
      const total = (price + tax) / 100; // 转换为元单位
      console.log(total); // 输出 1.05
      ```
    5. 使用第三方库
      - 可以使用第三方库（如math.js、Decimal.js、Big.js等）来处理浮点数精度问题，这些库提供了更精确的数学运算。
      ```javascript
      // 使用Decimal.js库
      const Decimal = require('decimal.js');
      const result = new Decimal(0.1).plus(new Decimal(0.2));
      console.log(result.toString()); // 输出 "0.3"
      ```
    6. 使用toFixed()方法
      - 可以使用toFixed()方法将浮点数格式化为指定的小数位数，但要注意它返回的是字符串。
      - 例如，(0.1 + 0.2).toFixed(2)会返回"0.30"。
      ```javascript
      const sum = (0.1 + 0.2).toFixed(2);
      console.log(sum); // 输出 "0.30"
      ```
  ## 严格模式
    答：严格模式（Strict Mode）是JavaScript的一种运行模式，可以通过在脚本或函数的开头添加"use strict";来启用。它可以帮助开发者编写更安全、更高效的代码，避免一些常见的错误。
    1. 启用严格模式
      - 在脚本的开头或函数内部添加"use strict";。
      ```javascript
      "use strict";
      function myFunction() {
        // 严格模式下的代码
      }
      ```
    2. 严格模式的特点
      - 禁止使用未声明的变量：在严格模式下，使用未声明的变量会抛出错误。
      ```javascript
      "use strict";
      x = 10; // 抛出 ReferenceError: x is not defined
      ```
      - 禁止删除变量、函数和参数：在严格模式下，不能删除变量、函数或参数。
      ```javascript
      "use strict";
      var y = 20;
      delete y; // 抛出 SyntaxError: Delete of an unqualified identifier in strict mode.
      ```
  ## 函数的防抖和节流
    1. 防抖（Debouncing）
      答：防抖是一种优化技术，用于限制函数在连续触发时的执行频率。它会延迟函数的执行，直到一段时间内没有再次触发事件。
      - 适用于输入框输入、窗口调整大小等场景。
      - 实现方式是使用setTimeout()来延迟函数执行，如果在延迟期间再次触发事件，则清除之前的定时器。
      ```javascript
      function debounce(func, delay) {
        let timeout;
        return function(...args) {
          clearTimeout(timeout);
          timeout = setTimeout(() => {
            func.apply(this, args);
          }, delay);
        };
      }
      const handleResize = debounce(() => {
        console.log('Window resized!');
      }, 500);
      window.addEventListener('resize', handleResize);
      ```
    2. 节流（Throttling）
      答：节流是一种优化技术，用于限制函数在一定时间内的执行频率。它会确保函数在指定的时间间隔内只执行一次。
      - 适用于滚动事件、鼠标移动等高频触发的场景。
      - 实现方式是使用setTimeout()来控制函数的执行时间间隔。
      ```javascript
      function throttle(func, delay) {
        let lastTime = 0;
        return function(...args) {
          const now = Date.now();
          if (now - lastTime >= delay) {
            lastTime = now;
            func.apply(this, args);
          }
        };
      }
      const handleScroll = throttle(() => {
        console.log('Window scrolled!');
      }, 1000);
      window.addEventListener('scroll', handleScroll);
      ```
    3. 防抖和节流的区别
      答：
        - 防抖：在事件触发后，延迟执行函数，直到一段时间内没有再次触发事件。适用于需要等待用户输入完成后再执行的场景。
        - 节流：在一定时间间隔内只执行一次函数，适用于需要频繁触发但不需要每次都执行的场景。
      - 防抖可以减少函数调用次数，而节流可以控制函数的执行频率。
      ```javascript
      // 防抖示例
      const input = document.querySelector('input');
      input.addEventListener('input', debounce(() => {
        console.log('Input value:', input.value);
      }, 300));
    
      // 节流示例
      const button = document.querySelector('button');
      button.addEventListener('click', throttle(() => {
        console.log('Button clicked!');
      }, 1000));
      ```
  ## Map\Set和WeakMap\WeakSet
    答：Map、Set、WeakMap和WeakSet是JavaScript中用于存储数据的集合类型，它们有不同的特性和用途。
    1. Map
      - Map是一个键值对集合，允许使用任意类型的键（包括对象）。
      - 保持插入顺序，可以通过forEach()方法遍历。
      - 支持size属性获取元素数量。
      - 可以使用set()方法添加元素，使用get()方法获取元素，使用has()方法检查是否存在某个键。
      ```javascript
      const map = new Map();
      map.set('name', 'Alice');
      map.set('age', 30);
      console.log(map.get('name')); // 输出 "Alice"
      console.log(map.size); // 输出 2
      ```
    2. Set
      - Set是一个唯一值的集合，不允许重复元素。
      - 保持插入顺序，可以通过forEach()方法遍历。
      - 支持size属性获取元素数量。
      - 可以使用add()方法添加元素，使用has()方法检查是否存在某个值，使用delete()方法删除元素。
      ```javascript
      const set = new Set();
      set.add(1);
      set.add(2);
      set.add(1); // 重复元素不会被添加
      console.log(set.has(1)); // 输出 true
      console.log(set.size); // 输出 2
      ```
    3. WeakMap
      - WeakMap是一个键值对集合，但键必须是对象，且WeakMap不会阻止垃圾回收。
      - 不支持size属性和遍历方法。
      - 可以使用set()方法添加元素，使用get()方法获取元素，使用has()方法检查是否存在某个键。
      ```javascript
      const weakMap = new WeakMap();
      const obj = {};
      weakMap.set(obj, 'value');
      console.log(weakMap.get(obj)); // 输出 "value"
      ```
    4. WeakSet
      - WeakSet是一个唯一值的集合，但值必须是对象，且WeakSet不会阻止垃圾回收。
      - 不支持size属性和遍历方法。
      - 可以使用add()方法添加元素，使用has()方法检查是否存在某个值，使用delete()方法删除元素。
      ```javascript
      const weakSet = new WeakSet();
      const obj1 = {};
      const obj2 = {};
      weakSet.add(obj1);
      console.log(weakSet.has(obj1)); // 输出 true
      console.log(weakSet.has(obj2)); // 输出 false
      ```
    5. Map和Set的区别
      - Map允许使用任意类型的键，而Set只存储唯一值。
      - Map保持键值对的插入顺序，而Set保持值的插入顺序。
      - Map可以通过键获取值，而Set只能检查值是否存在。
      - Map支持size属性，而Set也支持size属性。
      ```javascript
      const map = new Map();
      map.set('key1', 'value1');
      map.set('key2', 'value2');
      console.log(map.get('key1')); // 输出 "value1"
    
      const set = new Set();
      set.add('value1');
      set.add('value2');
      console.log(set.has('value1')); // 输出 true
      ```
    6. WeakMap、WeakSet和Map、Set的区别
      - WeakMap和WeakSet的键/值必须是对象，而Map和Set可以使用任意类型的键/值。
      - WeakMap和WeakSet不会阻止垃圾回收，如果没有其他引用，键/值会被自动删除，而Map和Set会一直保留。
      - WeakMap和WeakSet不支持size属性和遍历方法，而Map和Set支持。
      ```javascript
      const weakMap = new WeakMap();
      const obj = {};
      weakMap.set(obj, 'value');
      // 如果obj没有其他引用，weakMap中的键值对会被垃圾回收
    
      const map = new Map();
      map.set('key', 'value');
      console.log(map.size); // 输出 1
      ```
    7. 使用场景
      - Map适用于需要频繁添加、删除和查找键值对的场景，特别是当键是对象时。
      - Set适用于需要存储唯一值的场景，如去重操作。
      - WeakMap适用于需要存储对象的元数据或缓存，但不希望阻止对象被垃圾回收的场景。
      - WeakSet适用于需要存储唯一对象的集合，但不希望阻止对象被垃圾回收的场景。
      ```javascript
      const userMap = new Map();
      userMap.set({ id: 1 }, 'Alice');
      userMap.set({ id: 2 }, 'Bob');
    
      const uniqueObjects = new Set();
      uniqueObjects.add({ name: 'Alice' });
      uniqueObjects.add({ name: 'Bob' });
    
      const weakUserMap = new WeakMap();
      const userObj = { id: 1 };
      weakUserMap.set(userObj, 'Alice'); // userObj可以被垃圾回收
      ```
  ## 浅拷贝和深拷贝
    答：在JavaScript中，浅拷贝和深拷贝是两种复制对象的方式，它们的区别在于对嵌套对象的处理方式。
    1. 浅拷贝
      - 浅拷贝只复制对象的第一层属性，对于嵌套对象，仍然引用原始对象中的嵌套对象。
      - 可以使用Object.assign()、Array.prototype.slice()、扩展运算符（...）等方法实现浅拷贝。
      ```javascript
      const original = { a: 1, b: { c: 2 } };
      const shallowCopy = Object.assign({}, original);
      shallowCopy.b.c = 3; // 修改嵌套对象
      console.log(original.b.c); // 输出 3，原始对象也被修改了
      ```
    2. 深拷贝
      - 深拷贝会递归地复制对象及其所有嵌套对象，确保新对象与原始对象完全独立。
      - 可以使用JSON.parse(JSON.stringify())、递归函数或第三方库（如Lodash的cloneDeep）实现深拷贝。
      ```javascript
      const original = { a: 1, b: { c: 2 } };
      const deepCopy = JSON.parse(JSON.stringify(original));
      deepCopy.b.c = 3; // 修改嵌套对象
      console.log(original.b.c); // 输出 2，原始对象未被修改
      ```
    3. 使用场景
      - 浅拷贝适用于简单对象或不包含嵌套对象的情况，可以提高性能。
      - 深拷贝适用于需要完全独立副本的复杂对象，尤其是包含嵌套对象时。
    4. 深拷贝的方法
      - 使用JSON方法：适用于对象中只包含可序列化的值（如字符串、数字、布尔值、数组和对象），不适用于函数、Symbol、undefined等。
      ```javascript
      const original = { a: 1, b: { c: 2 } };
      const deepCopy = JSON.parse(JSON.stringify(original));
      ```
      - 使用递归函数：可以处理更复杂的对象，包括函数和特殊类型。
      ```javascript
      function deepClone(obj) {
        if (obj === null || typeof obj !== 'object') return obj;
        if (Array.isArray(obj)) return obj.map(deepClone);
        const clone = {};
        for (const key in obj) {
          clone[key] = deepClone(obj[key]);
        }
        return clone;
      }
      const original = { a: 1, b: { c: 2 } };
      const deepCopy = deepClone(original);
      ```
      - 使用第三方库：如Lodash的cloneDeep方法，可以处理更复杂的情况。
      ```javascript
      const _ = require('lodash');
      const original = { a: 1, b: { c: 2 } };
      const deepCopy = _.cloneDeep(original);
      ```
    5. 注意事项
      - 注意循环引用
      - 特殊类型处理：Map、Set、Date、RegExp、Function等
      - 通过getOwnPropertySymbols()获取Symbol属性
      - 保留原型链
      - 保留属性描述符 getOwnPropertyDescriptor()
  ## 函数柯里化
    答：函数柯里化（Currying）是一种将接受多个参数的函数转换为一系列接受单一参数的函数的技术。它允许你将一个多参数函数转换为一系列嵌套的单参数函数，从而可以部分应用参数。
    1. 基本概念
      - 柯里化的主要目的是将一个多参数函数转换为多个单参数函数，使得每次调用都只传递一个参数。
      - 通过柯里化，可以创建更灵活和可重用的函数。
      ```javascript
      function add(a) {
        return function(b) {
          return a + b;
        };
      }
      const add5 = add(5); // 返回一个新函数，固定第一个参数为5
      console.log(add5(10)); // 输出 15
      ```
    2. 实现方式
      - 可以使用闭包来实现柯里化，将外部函数的参数存储在内部函数中。
      ```javascript
      function curry(fn) {
        return function curried(...args) {
          if (args.length >= fn.length) {
            return fn(...args); // 如果传入的参数数量足够，直接调用原函数
          }
          return function(...args2) {
            return curried(...args, ...args2); // 否则继续收集参数
          };
        };
      }
      const add = (a, b, c) => a + b + c;
      const curriedAdd = curry(add);
      console.log(curriedAdd(1)(2)(3)); // 输出 6
      ```
    3. 使用场景
      - 柯里化适用于需要部分应用参数的场景，可以提高代码的可读性和可维护性。
      - 常用于函数式编程和高阶函数中，可以创建更灵活的函数组合。
      - 固定参数，可以通过柯里化创建特定的函数版本，减少重复代码。
      ```javascript
      function multiply(a, b) {
        return a * b;
      }
      const curriedMultiply = curry(multiply);
      const double = curriedMultiply(2); // 固定第一个参数为2
      console.log(double(5)); // 输出 10
      ```
      - 提前判断:如创建函数的时候判断环境，就不需要再实际调用时多次判断环境
      ```javascript
const fn = (()=>{
  if(env.isWindows){
    return function(a,b){
      `window${a+b}`
    }
  }else{
    return function(a,b){
      `other{a+b}`
    }
  }
})();

      ```
    
    4. 注意事项
      - 柯里化可能会增加代码复杂度，尤其是在处理大量参数时。
      - 柯里化后的函数需要注意返回值类型，确保正确处理结果。
    
    5. 实现：
      - add(1,2,3) => 6
      - add(1)(2,3)(4) => 10
      - add(1)(2)(3)(4)(5) => 15
      ```javascript
function add(...args) {
  const argsArr = [...args];
  const innerAdd = (...innerArgs)=>{
    argsArr.push(...innerArgs);
    return innerAdd;
  }

  innerAdd.toString = () => {
    return argsArr.reduce((sum, current) => sum + current, 0);
  }

  return innerAdd
}
console.log(add(1, 2, 3).toString()) // 输出 6
console.log(add(1)(2, 3)(4).toString()) // 输出 10
console.log(add(1)(2)(3)(4)(5).toString()) // 输出 15

      ```
  ## 进程和线程
    答：进程和线程是操作系统中用于管理和调度程序执行的基本概念。它们在资源分配、执行方式和并发性方面有显著区别。
      JS是单线程的，但Node.js可以通过异步I/O和事件循环来处理并发任务。以下是进程和线程的主要区别：
    1. 进程
      - 进程是操作系统分配资源的基本单位，是正在运行的程序实例。
      - 每个进程都有自己的内存空间、代码段、数据段和堆栈。
      - 进程之间相互独立，不能直接访问其他进程的内存空间。
      - 进程可以包含多个线程，线程共享同一进程的资源。
      - 在Node.js中，每个Node.js应用程序都是一个单独的进程。
    2. 线程
    
      - 线程是进程中的一个执行单元，是CPU调度的基本单位。
      - 线程共享同一进程的内存空间和资源，但每个线程有自己的执行栈和局部变量。
      - 多线程可以提高程序的并发性和性能，但也会增加复杂性，如死锁、竞态条件等问题。
      - 在Node.js中，JavaScript代码运行在单线程中，但可以使用Worker Threads模块创建多线程。


  ## Node的事件循环
    答：Node.js的事件循环是其异步编程模型的核心，允许Node.js处理大量并发连接而不会阻塞。事件循环分为多个阶段，每个阶段都有特定的任务队列。以下是事件循环的主要阶段和流程：
    1. 初始化阶段
      - Node.js启动时会初始化事件循环，设置必要的资源和环境。
    2. 执行栈
      - JavaScript代码执行时，会将函数调用压入执行栈（Call Stack）。当函数执行完成后，会从栈中弹出。
    3. 阶段划分
      - 事件循环分为多个阶段，每个阶段都有自己的任务队列，包括：
        - timers：处理setTimeout和setInterval的回调。
        - I/O callbacks：处理I/O操作的回调，如文件读写、网络请求等。
        - idle, prepare：内部使用，不对外暴露。
        - poll：检查新的I/O事件，执行相应的回调。
        - check：处理setImmediate的回调。
        - close callbacks：处理关闭事件，如socket关闭。
    4. 事件循环流程
      - 在每个循环迭代中，Node.js会按照以下顺序执行任务：
        1. 执行执行栈中的同步代码。
        2. 执行timers阶段中的定时器回调。
        3. 执行I/O callbacks阶段中的I/O操作回调。
        4. 执行poll阶段中的I/O事件回调，如果没有新的I/O事件，则进入check阶段。
        5. 执行check阶段中的setImmediate回调。
        6. 执行close callbacks阶段中的关闭事件回调。
      - 如果在某个阶段没有任务需要执行，Node.js会等待新的事件或定时器触发，然后继续下一轮循环。
    5. 异步操作
      - Node.js通过异步操作（如文件读写、网络请求等）来避免阻塞主线程。当异步操作完成时，对应的回调函数会被放入相应的任务队列中，等待事件循环处理。
    6. 微任务队列
      - 在每个阶段结束后，Node.js
会检查微任务队列（Microtask Queue），执行所有微任务（如Promise的then回调）。微任务队列会在当前阶段的所有任务执行完毕后立即执行，确保微任务优先于下一个阶段的任务。
      - 微任务队列通常用于处理Promise的回调和MutationObserver等。
    7. 注意事项
      - 每个阶段开始前，Node.js会清空执行栈中的所有同步代码，每个阶段结束后，都会检查微任务队列并执行所有微任务。
      - 事件循环是单线程的，所有的I/O操作都是异步的，避免了阻塞。
      - 在事件循环中，长时间运行的同步代码会阻塞事件循环，导致其他任务无法执行。
      - 使用setImmediate和process.nextTick可以控制任务的执行顺序，确保在当前阶段结束后立即执行特定任务。
      - timers 的时间是不准确的，只能尽快执行
      - setImmediate 在当前阶段结束后执行，而 setTimeout 在下一个阶段开始时执行。
      - process.nextTick 在当前阶段的末尾执行，优先级最高。

    8. 示例
      ```javascript
      console.log('Start'); // 同步代码
    
      setTimeout(() => {
        console.log('Timeout 1'); // timers阶段
      }, 0);
    
      setImmediate(() => {
        console.log('Immediate 1'); // check阶段
      });
    
      Promise.resolve().then(() => {
        console.log('Promise 1'); // 微任务队列
      });
    
      setTimeout(() => {
        console.log('Timeout 2'); // timers阶段
      }, 100);
    
      console.log('End'); // 同步代码
    
      // 输出顺序：
      // Start
      // End
      // Promise 1
      // Timeout 1
      // Immediate 1
      // Timeout 2 (在100ms后)
      ```
  ## 浏览器的任务循环
    答：浏览器的任务循环（Event Loop）是处理异步事件和任务的机制，允许浏览器在执行JavaScript代码时处理用户交互、网络请求等事件。浏览器的任务循环与Node.js的事件循环类似，但有一些不同之处。以下是浏览器任务循环的主要阶段和流程：
    1. 初始化阶段
      - 浏览器加载页面时，会初始化任务循环，设置必要的资源和环境。
    2. 执行栈
      - JavaScript代码执行时，会将函数调用压入执行栈（Call Stack）。当函数执行完成后，会从栈中弹出。
    3. 阶段划分
      - 任务循环分为多个阶段，每个阶段都有自己的任务队列，包括：
        - 微任务队列（Microtask Queue）：用于处理Promise的回调和MutationObserver等。
        - 宏任务队列（Macrotask Queue）：用于处理setTimeout、setInterval、I/O操作等。
    4. 任务循环流程
      - 在每个循环迭代中，浏览器会按照以下顺序执行任务：
        1. 执行执行栈中的同步代码。
        2. 执行微任务队列中的所有微任务（如Promise的then回调）。
        3. 执行宏任务队列中的第一个宏任务（如setTimeout回调）。
        4. 重复步骤2和3，直到宏任务队列为空。
      - 如果在某个阶段没有任务需要执行，浏览器会等待新的事件或定时器触发，然后继续下一轮循环。
    5. 异步操作
      - 浏览器通过异步操作（如网络请求、用户交互等）来避免阻塞主线程。当异步操作完成时，对应的回调函数会被放入相应的任务队列中，等待任务循环处理。
    6. 注意事项
      - 浏览器的任务循环是单线程的，所有的JavaScript代码都是在主线程中执行的，避免了多线程带来的复杂性。
      - 在任务循环中，长时间运行的同步代码会阻塞主线程，导致其他事件无法及时处理。
      - 使用requestAnimationFrame可以在浏览器的下一帧渲染前执行特定任务，适用于动画和界面更新。

  ## 浏览器和Node任务循环的差别
    答：浏览器和Node.js的任务循环（Event Loop）在基本原理上相似，但在实现细节和处理方式上有一些重要的区别。以下是它们之间的主要差异：
    1. 任务队列
      - 浏览器的任务循环通常分为宏任务队列（Macrotask Queue）和微任务队列（Microtask Queue）。宏任务包括setTimeout、setInterval等，而微任务包括Promise的then回调和MutationObserver等。
      - Node.js的事件循环也有类似的概念，但它使用了不同的阶段来处理I/O操作和定时器回调，如timers、I/O callbacks、poll、check等。
    2. 执行顺序
      - 在浏览器中，执行顺序是先执行同步代码，然后执行微任务队列中的所有微任务，最后执行宏任务队列中的第一个宏任务。
      - 在Node.js中，事件循环会在每个阶段结束后检查微任务队列，并执行所有微任务，然后继续下一个阶段。
    3. 异步操作
      - 浏览器中的异步操作通常涉及用户交互、网络请求等，而Node.js中的异步操作更多地涉及文件系统、网络通信等服务器端操作。
      - Node.js提供了更多的异步API，如fs模块用于文件操作，http模块用于网络通信，这些API通常会将回调函数放入相应的任务队列中等待处理。
    4. requestAnimationFrame
      - 浏览器提供了requestAnimationFrame方法，用于在浏览器下一帧渲染前执行特定任务，适用于动画和界面更新。
      - Node.js没有类似的API，因为它主要用于服务器端编程，不涉及浏览器渲染。
    5. 事件源
      - 浏览器中的事件源包括用户交互（如点击、输入）、网络请求、定时器等。
      - Node.js中的事件源主要是I/O操作，如文件读写、网络请求等。
    6. 全局对象
      - 在浏览器中，全局对象是window，而在Node.js中，全局对象是global。这影响了全局变量和函数的访问方式。
    7. 模块系统
      - 浏览器使用ES6模块（import/export）或传统的script标签来加载脚本，而Node.js使用CommonJS模块（require/module.exports）或ES6模块来加载模块。这影响了代码组织和依赖管理的方式。
  ## eval
    答：eval是一个JavaScript内置函数，用于将字符串作为代码执行。它可以在浏览器和Node.js中使用，但存在一些安全和性能问题。以下是eval的一些关键点：
    - 安全性：使用eval可能导致安全漏洞，因为它会执行任何传入的代码，包括恶意代码。因此，应该避免在不信任的输入上使用eval。

  ## JS中的尺寸和位置
    1. DOM对象相关尺寸和位置属性
      - 在浏览器中，可以使用以下属性获取DOM元素的尺寸和位置信息：
        以下是只读的属性和方法，用于获取元素的尺寸和位置信息：
        - clientWidth/clientHeight：元素的可见宽度和高度，不包括滚动条。
        - offsetWidth/offsetHeight：元素的总宽度和高度，包括边框和滚动条。
        - offsetLeft/offsetTop：元素相对于其最近的定位祖先元素的左上角位置。
        - scrollWidth/scrollHeight：元素的内容区域宽度和高度，包括不可见部分。没有不可见区域时，等于clientWidth/clientHeight。
        - getBoundingClientRect()：返回元素的大小及其相对于视口的位置。
        可读可写:
        - scrollLeft/scrollTop：元素的滚动位置，表示内容区域相对于可见区域的偏移量。
        - domObj.style.xxx 属性
      ```javascript
      const element = document.querySelector('.my-element');
      console.log(element.clientWidth, element.clientHeight);
      console.log(element.offsetWidth, element.offsetHeight);
      console.log(element.scrollWidth, element.scrollHeight);
      const rect = element.getBoundingClientRect();
      console.log(rect.top, rect.left, rect.width, rect.height);
      ```
    2. 事件对象
      - 在事件处理函数中，可以使用event对象获取鼠标或触摸事件的位置信息：
        - clientX/clientY：鼠标相对于视口的位置。
        - pageX/pageY：鼠标相对于整个文档的位置。
        - screenX/screenY：鼠标相对于屏幕的位置。
      ```javascript
      document.addEventListener('click', (event) => {
        console.log(event.clientX, event.clientY);
        console.log(event.pageX, event.pageY);
        console.log(event.screenX, event.screenY);
      });
      ```
  ## 迭代器和生成器
    答：迭代器和生成器是JavaScript中用于处理可迭代对象的概念，它们提供了一种统一的方式来遍历数据结构。
    1. 迭代器（Iterator）
      - 迭代器是一个对象，它定义了一个next()方法，用于返回集合中的下一个值。
      - 迭代器遵循Iterator协议，即具有next()方法，该方法返回一个包含value和done属性的对象。
      - 可以使用for...of循环来遍历迭代器。
      ```javascript
      const myArray = [1, 2, 3];
      const iterator = myArray[Symbol.iterator](); // 获取数组的迭代器
      console.log(iterator.next()); // { value: 1, done: false }
      console.log(iterator.next()); // { value: 2, done: false }
      console.log(iterator.next()); // { value: 3, done: false }
      console.log(iterator.next()); // { value: undefined, done: true }
      ```
    2. 生成器（Generator）
      - 生成器是一个特殊类型的函数，可以暂停和恢复执行，使用function*语法定义。
      - 生成器函数返回一个迭代器，可以使用yield关键字来生成值。
      - 每次调用next()方法时，生成器函数会执行到下一个yield语句，并返回yield后的值。
      ```javascript
      function* myGenerator() {
        yield 1;
        yield 2;
        yield 3;
      }
      const gen = myGenerator(); // 创建生成器实例
      console.log(gen.next()); // { value: 1, done: false }
      console.log(gen.next()); // { value: 2, done: false }
      console.log(gen.next()); // { value: 3, done: false }
      console.log(gen.next()); // { value: undefined, done: true }
      ```

  ## 代理和反射
    答：代理（Proxy）和反射（Reflect）是JavaScript中用于操作对象的强大工具。它们允许开发者拦截和修改对象的行为。
    1. 代理（Proxy）
      - Proxy是一个用于创建代理对象的构造函数，可以拦截对目标对象的操作，如属性访问、赋值、函数调用等。
      - 通过定义处理程序（handler）对象，可以指定如何处理这些操作。
      ```javascript
      const target = {
        message: 'Hello, World!'
      };
      const handler = {
        get: function(obj, prop) {
          return prop in obj ? obj[prop] : 'Property not found';
        }
      };
      const proxy = new Proxy(target, handler);
      console.log(proxy.message); // 输出 "Hello, World!"
      console.log(proxy.nonExistent); // 输出 "Property not found"
      ```
    2. 反射（Reflect）
      - Reflect是一个内置对象，提供了一组静态方法，用于操作对象的属性和行为。
      - 它与Proxy一起使用，可以更方便地实现代理功能。
      ```javascript
      const target = {
        message: 'Hello, World!'
      };
      const handler = {
        get: function(obj, prop) {
          return Reflect.get(obj, prop) || 'Property not found';
        }
      };
      const proxy = new Proxy(target, handler);
      console.log(proxy.message); // 输出 "Hello, World!"
      console.log(proxy.nonExistent); // 输出 "Property not found"
      ```
    3. 使用场景
      - 代理可以用于数据验证、属性访问控制、函数调用拦截等场景。
      - 反射可以用于简化对对象属性的操作，如获取、设置、删除属性等。
  ## Promise
    答：Promise是JavaScript中用于处理异步操作的对象，它代表一个可能在未来某个时间点完成或失败的操作。Promise提供了一种更清晰和可读的方式来处理异步代码，避免了回调地狱的问题。
    1. 基本概念
      - Promise有三种状态：
        - pending（待定）：初始状态，表示操作尚未完成。
        - fulfilled（已完成）：表示操作成功完成，并返回结果。
        - rejected（已拒绝）：表示操作失败，并返回错误信息。
      - 一旦Promise的状态从pending变为fulfilled或rejected，就不能再改变。
    2. 创建Promise
      - 可以使用Promise构造函数创建一个新的Promise对象，传入一个执行器函数，该函数接受resolve和reject两个参数，用于改变Promise的状态。
      ```javascript
      const myPromise = new Promise((resolve, reject) => {
        // 异步操作
        setTimeout(() => {
          const success = true; // 模拟成功或失败
          if (success) {
            resolve('Operation succeeded!'); // 改变状态为fulfilled
          } else {
            reject('Operation failed!'); // 改变状态为rejected
          }
        }, 1000);
      });
      ```
    3. 使用Promise
      - 可以使用then()方法处理fulfilled状态的结果，catch()方法处理rejected状态的错误，finally()方法在Promise结束时执行，无论结果如何。
      ```javascript
      myPromise
        .then(result => {
          console.log(result); // 输出 "Operation succeeded!"
        })
        .catch(error => {
          console.error(error); // 输出 "Operation failed!"
        })
        .finally(() => {
          console.log('Promise completed!'); // 无论成功或失败都会执行
        });
      ```
    4. 链式调用
      - Promise支持链式调用，可以在then()方法中返回新的Promise，从而实现多个异步操作的串联。
      ```javascript
      myPromise
        .then(result => {
          console.log(result);
          return new Promise((resolve) => resolve('Next operation succeeded!'));
        })
        .then(nextResult => {
          console.log(nextResult); // 输出 "Next operation succeeded!"
        }).then(null, error => {
          console.error(error); // 如果有错误会在这里捕获,等效于catch
        });
      ```
    5. 静态方法
      - Promise提供了一些静态方法，用于简化Promise的创建和处理。
      - Promise.all()：接受一个包含多个Promise的数组，返回一个新的Promise，当所有Promise都成功时，返回一个包含所有结果的数组；如果有任何一个Promise失败，则返回失败的错误。
      ```javascript
      const promise1 = Promise.resolve(1);
      const promise2 = Promise.resolve(2);
      const promise3 = Promise.resolve(3);
      Promise.all([promise1, promise2, promise3])
        .then(results => {
          console.log(results); // 输出 [1, 2, 3]
        })
        .catch(error => {
          console.error(error); // 如果有任何一个Promise失败，则在这里捕获
        });
      ```
      - Promise.race()：接受一个包含多个Promise的数组，返回一个新的Promise，当其中一个Promise成功或失败时，返回该Promise的结果。
      ```javascript
      const promise1 = new Promise((resolve) => setTimeout(() => resolve('Promise 1'), 1000));
      const promise2 = new Promise((resolve) => setTimeout(() => resolve('Promise 2'), 500));
      const promise3 = new Promise((resolve) => setTimeout(() => resolve('Promise 3'), 2000));
      Promise.race([promise1, promise2, promise3])
        .then(result => {
          console.log(result); // 输出 "Promise 2"，因为它是最先完成的
        })
        .catch(error => {
          console.error(error); // 如果有任何一个Promise失败，则在这里捕获
        });
      ```
      - Promise.allSettled()：接受一个包含多个Promise的数组，返回一个新的Promise，当所有Promise都完成时，返回一个包含每个Promise结果的数组，无论它们是成功还是失败。
      ```javascript
      const promise1 = Promise.resolve(1);
      const promise2 = Promise.reject('Error in promise 2');
      const promise3 = Promise.resolve(3);
      Promise.allSettled([promise1, promise2, promise3])
        .then(results => {
          console.log(results);
          // 输出 [
          //   { status: 'fulfilled', value: 1 },
          //   { status: 'rejected', reason: 'Error in promise 2' },
          //   { status: 'fulfilled', value: 3 }
          // ]
        });
      ```
      - Promise.any()：接受一个包含多个Promise的数组，返回一个新的Promise，当其中一个Promise成功时，返回该Promise的结果；如果所有Promise都失败，则返回一个AggregateError。
      ```javascript
      const promise1 = Promise.reject('Error in promise 1');
      const promise2 = Promise.reject('Error in promise 2');
      const promise3 = Promise.resolve('Promise 3 succeeded!');
      Promise.any([promise1, promise2, promise3])
        .then(result => {
          console.log(result); // 输出 "Promise 3 succeeded!"
        })
        .catch(error => {
          console.error(error); // 如果所有Promise都失败，则在这里捕获AggregateError
        });
      ```
      - Promise.resolve()：将一个值包装为一个已完成的Promise。
      ```javascript
      const resolvedPromise = Promise.resolve('Resolved value');
      resolvedPromise.then(value => {
        console.log(value); // 输出 "Resolved value"
      });
      ```
      - Promise.reject()：将一个错误包装为一个已拒绝的Promise。
      ```javascript
      const rejectedPromise = Promise.reject('Rejected error');
      rejectedPromise.catch(error => {
        console.error(error); // 输出 "Rejected error"
      });
      ```
  ## async\await
    答：async/await是JavaScript中用于处理异步操作的语法糖，它基于Promise，提供了一种更简洁和可读的方式来编写异步代码。以下是async/await的主要概念和用法：
    1. async函数
      - 使用async关键字定义一个异步函数，该函数会返回一个Promise。
      - 在async函数内部，可以使用await关键字等待一个Promise的结果。
      ```javascript
      async function myAsyncFunction() {
        return 'Hello, World!'; // 返回一个已完成的Promise
      }
      myAsyncFunction().then(result => {
        console.log(result); // 输出 "Hello, World!"
      });
      ```
    2. await关键字
      - await关键字只能在async函数内部使用，用于等待一个Promise的结果。
      - 当遇到await时，函数会暂停执行，直到Promise完成，然后继续执行后续代码。
      ```javascript
      async function fetchData() {
        const response = await fetch('https://api.example.com/data'); // 等待fetch请求完成
        const data = await response.json(); // 等待解析JSON数据
        console.log(data); // 输出获取到的数据
      }
      fetchData();
      ```
    3. 错误处理
      - 可以使用try...catch语句来处理async函数中的错误，捕获await表达式抛出的异常。
      ```javascript
      async function fetchData() {
        try {
          const response = await fetch('https://api.example.com/data');
          if (!response.ok) {
            throw new Error('Network response was not ok');
          }
          const data = await response.json();
          console.log(data);
        } catch (error) {
          console.error('Fetch error:', error); // 捕获并处理错误
        }
      }
      fetchData();
      ```
    4. 并行执行多个异步操作
      - 可以使用Promise.all()结合async/await来并行执行多个异步操作。
      ```javascript
      async function fetchData() {
        const [data1, data2, data3] = await Promise.all([
          fetch('https://api.example.com/data1').then(res => res.json()),
          fetch('https://api.example.com/data2').then(res => res.json()),
          fetch('https://api.example.com/data3').then(res => res.json())
        ]);
        console.log(data1, data2, data3);
      }
      fetchData();
      ```
    5. 注意事项
      - async/await是基于Promise的，因此需要确保在使用await时，等待的对象是一个Promise。
      - async函数始终返回一个Promise，即使函数内部没有显式返回值，也会返回一个已完成的Promise。
      - 使用async/await可以使异步代码更易读，但仍需注意错误处理和性能问题。
  # 浏览器
    ## 浏览器的渲染过程
    答：在此之前会进行DNS解析、TCP连接、SSL握手等网络请求的准备工作。
    答：浏览器的渲染过程是将HTML、CSS和JavaScript转换为可视化内容的过程。以下是浏览器渲染的主要步骤：
    1. 解析HTML
      - 浏览器首先解析HTML文档，将其转换为DOM（Document Object Model）树。DOM树是一个表示文档结构的树形结构，每个节点代表一个HTML元素。
      - 在解析过程中，浏览器会处理标签、属性和文本内容，并构建出完整的DOM树。
      - 主线程如果解析到js脚本标签，会暂停DOM树的构建，执行脚本后再继续解析。(可以用async和defer来优化)
    2. 解析CSS
      - 浏览器接着解析CSS样式表，将其转换为CSSOM（CSS Object Model）树。CSSOM树表示文档的样式信息，包括选择器、属性和值。
      - CSS样式可以来自内联样式、内部样式表和外部样式表，浏览器会合并这些样式并应用优先级规则。
    3. 构建渲染树
      - 浏览器将DOM树和CSSOM树结合起来，构建渲染树（Render Tree）。渲染树包含了可见的元素及其样式信息，但不包括不可见的元素（如display: none的元素）。
      - 渲染树中的每个节点称为渲染对象（Render Object），它包含了元素的几何信息和样式信息。
      - 渲染树的构建过程中，浏览器会计算每个元素的大小、位置和样式，并将其转换为可视化内容。
    4. 布局（Layout）
      - 布局阶段（也称为回流）是计算渲染树中每个元素的确切位置和大小的过程。
      - 浏览器会遍历渲染树，根据元素的样式和父子关系计算出每个元素在页面上的位置和尺寸。
      - 布局阶段可能会受到CSS属性（如position、float、flex等）的影响，浏览器会根据这些属性进行相应的布局计算。
      - 布局完成后，浏览器会生成一个布局图（Layout），表示每个元素的几何信息。
    5. 绘制（Painting）
      - 绘制阶段（重绘）是将渲染树中的每个元素转换为实际的像素内容，并绘制到屏幕上的过程。
      - 浏览器会根据布局图和样式信息，绘制每个元素的背景、边框、文本等内容。
      - 绘制过程中，浏览器会将元素分成多个层（Layer），以提高渲染性能和处理复杂的视觉效果。
      - 每个层可以独立地进行绘制和合成，浏览器会将这些层合并成最终的图像，并显示在屏幕上。
    ## 浏览器缓存
    1. 浏览器缓存
      - 浏览器缓存是指浏览器在本地存储静态资源（如HTML、CSS、JavaScript、图片等），以减少网络请求和提高页面加载速度。
      - 浏览器缓存可以分为强缓存和协商缓存两种类型。
    2. 强缓存
      - 强缓存是指浏览器在本地缓存资源，并在下次请求时直接使用缓存，而不向服务器发送请求。
      - 强缓存通过HTTP头部的Cache-Control和Expires字段来控制。
        - Cache-Control：指定缓存策略，如max-age（最大年龄）、no-cache（不使用缓存）等。
        - Expires：指定资源的过期时间，过期后需要重新请求资源。
      - 如果强缓存未过期，浏览器会直接使用本地缓存，不会向服务器发送请求，从而提高加载速度。
    3. 协商缓存
      - 协商缓存是指浏览器向服务器发送请求，询问资源是否被修改，如果未修改则使用本地缓存，否则重新下载资源。
      - 协商缓存通过HTTP头部的Last-Modified和ETag字段来实现。
        - Last-Modified：服务器返回资源的最后修改时间，浏览器在下次请求时会发送If-Modified-Since头部，询问资源是否被修改。
        - ETag：服务器返回资源的唯一标识符，浏览器在下次请求时会发送If-None-Match头部，询问资源是否被修改。
      - 如果服务器返回304 Not Modified，则表示资源未修改，浏览器可以使用本地缓存；如果返回200 OK，则表示资源已修改，浏览器需要重新下载资源。
      - 协商缓存可以减少不必要的网络请求，提高资源的加载效率。
    4. 何时使用
      - 强缓存适用于静态资源，如图片、CSS、JavaScript等，这些资源通常不会频繁修改，可以通过设置合理的过期时间来提高加载速度。
      - 协商缓存适用于动态资源，如API接口、用户数据等，这些资源可能会频繁修改，需要与服务器进行协商以获取最新数据。
      - html文件通常不使用强缓存，因为它们可能会频繁更新，建议使用协商缓存来确保获取最新版本。
  # 网络
    ## 五层网络模型
      - OSI模型（Open Systems Interconnection Model）是一个七层网络模型，但在实际应用中，通常使用简化的五层模型来描述网络通信。五层模型包括：
        1. 应用层（Application Layer）：处理用户应用程序之间的通信，如HTTP、FTP、SMTP等协议。
        2. 传输层（Transport Layer）：提供端到端的通信服务，确保数据的可靠传输，如TCP、UDP等协议。
        3. 网络层（Network Layer）：负责数据包的路由和转发，如IP协议。
        4. 数据链路层（Data Link Layer）：处理物理网络上的数据传输，如以太网、Wi-Fi等协议。
        5. 物理层（Physical Layer）：定义物理媒介和信号传输方式，如电缆、光纤等。
    ## HTTP协议
      1. HTTP协议概述
        - HTTP（HyperText Transfer Protocol）是Web上用于传输数据的协议，它定义了客户端（通常是浏览器）和服务器之间的通信规则。
        - HTTP协议是无状态的，即每个请求都是独立的，服务器不会保留之前请求的状态信息。
        - HTTP协议使用请求-响应模型，客户端发送请求，服务器返回响应。
        - HTTP协议有多个版本，最常用的是HTTP/1.1和HTTP/2。HTTP/2引入了多路复用、头部压缩等性能优化特性。
      2. HTTP请求
        - HTTP请求由请求行、请求头和请求体组成。
          - 请求行：包含HTTP方法（如GET、POST、PUT、DELETE等）、请求URL和HTTP版本。
          - 请求头：包含一些元数据，如User-Agent、Accept、Content-Type等，用于描述客户端的能力和请求的内容类型。
          - 请求体：可选部分，通常用于POST或PUT请求，包含要发送给服务器的数据。
        - 常见的HTTP方法包括：
          - GET：用于获取资源，不应有副作用。
          - POST：用于提交数据，可能会创建或修改资源。
          - PUT：用于更新资源，通常是幂等的。
          - DELETE：用于删除资源。
          - PATCH：用于部分更新资源。
          - Update：用于更新资源，通常是幂等的。
      3. HTTP响应
        - HTTP响应由状态行、响应头和响应体组成。
          - 状态行：包含HTTP版本、状态码和状态消息。状态码表示请求的处理结果，如200（成功）、404（未找到）、500（服务器错误）等。
          - 响应头：包含一些元数据，如Content-Type、Content-Length、Set-Cookie等，用于描述响应的内容类型和其他信息。
          - 响应体：包含实际的响应数据，如HTML、JSON、图片等。
        - 响应码
          - 1xx：信息性状态码，表示请求已接收，继续处理。
          - 2xx：成功状态码，表示请求已成功处理，如200（OK）、201（Created）等。
          - 3xx：重定向状态码，表示需要进一步操作以完成请求，如301（Moved Permanently）、302（Found）等。
          - 4xx：客户端错误状态码，表示请求有误，如400（Bad Request）、404（Not Found）等。
          - 5xx：服务器错误状态码，表示服务器处理请求时发生错误，如500（Internal Server Error）、502（Bad Gateway）等）。
        - 常见的状态码包括：
          - 200 OK：请求成功，服务器返回所请求的资源。
          - 201 Created：请求成功，服务器创建了新资源。
          - 204 No Content：请求成功，但没有返回内容。
          - 304 Not Modified：资源未修改，可以使用缓存。
          - 400 Bad Request：请求有误，服务器无法理解。
          - 401 Unauthorized：需要身份验证。
          - 403 Forbidden：禁止访问，服务器拒绝请求。
          - 404 Not Found：请求的资源未找到。
          - 500 Internal Server Error：服务器内部错误，无法处理请求。
          - 502 Bad Gateway：网关错误，服务器作为网关或代理时收到无效响应。
      4. 版本差异
        - HTTP/1.0：最初的HTTP版本，支持简单的请求和响应，但不支持持久连接和管道化请求。
        - HTTP/1.1：引入了持久连接（Keep-Alive）、管道化请求、分块传输编码等特性，支持更高效的请求和响应处理。
        - HTTP/2：引入了多路复用、头部压缩、服务器推送等特性，显著提高了性能和效率。
        - HTTP/3：基于QUIC协议，使用UDP传输，进一步减少延迟和提高性能。
    ## 跨域
      1. 什么是跨域
        - 跨域是指在浏览器中，脚本试图访问不同源（协议、域名、端口）的资源时，浏览器会阻止这种行为，以保护用户的安全和隐私。
        - 同源策略（Same-Origin Policy）是浏览器的一种安全机制，它限制了脚本只能访问与当前页面同源的资源。
      2. 如何解决跨域问题
        - JSONP：通过动态创建script标签来加载跨域数据，但只支持GET请求，存在安全隐患。
        - CORS（Cross-Origin Resource Sharing）：服务器通过设置响应头部的Access-Control-Allow-Origin等字段来允许跨域请求，支持多种HTTP方法。
        - 代理服务器：通过设置代理服务器，将跨域请求转发到同源服务器，从而绕过同源限制。
        - WebSocket：WebSocket协议不受同源限制，可以实现跨域通信，但需要服务器支持WebSocket协议。
        - document.domain：在同一主域下的子域之间可以通过设置document.domain来实现跨域通信，但需要满足一定条件。
        - postMessage：使用postMessage方法在不同窗口或iframe之间进行安全的跨域通信。
      3. CORS详解
        - CORS是一种W3C标准，它允许服务器通过设置HTTP头部来指定哪些源可以访问其资源，从而实现跨域请求。
        - CORS的工作原理如下：
          1. 浏览器发送预检请求（OPTIONS）以检查服务器是否允许跨域请求。
          2. 服务器在响应中设置Access-Control-Allow-Origin等CORS相关头部，指示浏览器是否允许跨域请求。
          3. 如果预检请求成功，浏览器会发送实际的跨域请求，并携带相应的CORS头部。
          4. 服务器处理实际请求并返回响应，如果允许跨域访问，则浏览器会将响应数据传递给脚本，否则会抛出错误。
        - 常见的CORS相关头部包括：
          - Access-Control-Allow-Origin：指定允许访问资源的源，可以是具体的URL或*（表示允许所有源）。
          - Access-Control-Allow-Methods：指定允许的HTTP方法，如GET、POST、PUT等。
          - Access-Control-Allow-Headers：指定允许的请求头部字段。
          - Access-Control-Allow-Credentials：指示是否允许携带凭据（如Cookies）进行跨域请求。
          - Access-Control-Max-Age：指定预检请求的结果可以缓存的时间（以秒为单位）。
    ## HTTP缓存
      1. HTTP缓存概述
        - HTTP缓存是指浏览器或代理服务器在本地存储资源，以减少网络请求和提高页面加载速度。
        - HTTP缓存可以分为强缓存和协商缓存两种类型。
      2. 强缓存
        - 强缓存是指浏览器在本地缓存资源，并在下次请求时直接使用缓存，而不向服务器发送请求。
        - 强缓存通过HTTP头部的Cache-Control和Expires字段来控制。
          - Cache-Control：指定缓存策略，如max-age（最大年龄）、no-cache（不使用缓存）等。
          - Expires：指定资源的过期时间，过期后需要重新请求资源。
      3. 协商缓存
        - 协商缓存是指浏览器向服务器发送请求，询问资源是否被修改，如果未修改则使用本地缓存，否则重新下载资源。
        - 协商缓存通过HTTP头部的Last-Modified和ETag字段来实现。
          - Last-Modified：服务器返回资源的最后修改时间，浏览器在下次请求时会发送If-Modified-Since头部，询问资源是否被修改。
          - ETag：服务器返回资源的唯一标识符，浏览器在下次请求时会发送If-None-Match头部，询问资源是否被修改。
        - 如果服务器返回304 Not Modified，则表示资源未修改，浏览器可以使用本地缓存；如果返回200 OK，则表示资源已修改，浏览器需要重新下载资源。
      4. 缓存控制
        - 可以通过设置HTTP头部来控制缓存行为，如Cache-Control、Expires、Last-Modified、ETag等。
        - 可以使用Pragma: no-cache和Cache-Control: no-store来禁用缓存，但这会增加网络请求负担，应谨慎使用。
    ## 输入url地址后
      1. 输入URL地址后，浏览器会进行以下步骤来加载页面：
        - DNS解析：将域名转换为IP地址，以便找到服务器。
        - TCP连接：建立与服务器的TCP连接，通常使用三次握手过程。
        - 发送HTTP请求：浏览器向服务器发送HTTP请求，请求所需的资源。
        - 接收HTTP响应：服务器处理请求并返回HTTP响应，包含所请求的资源。
        - 渲染页面：浏览器解析HTML、CSS和JavaScript，并渲染页面内容。
      2. DNS解析
        - 浏览器首先检查本地DNS缓存，如果缓存中有对应的IP地址，则直接使用；否则，向DNS服务器发送查询请求。
        - DNS服务器返回域名对应的IP地址，浏览器将其存储在本地DNS缓存中，以便下次使用。
      3. TCP连接
        - 浏览器与服务器建立TCP连接，通常使用三次握手过程：
          1. 客户端发送SYN包，请求建立连接。
          2. 服务器回复SYN-ACK包，确认连接请求。
          3. 客户端发送ACK包，完成连接建立。
      4. HTTP请求
        - 浏览器向服务器发送HTTP请求，请求所需的资源（如HTML、CSS、JavaScript等）。
        - 请求包含请求行、请求头和可选的请求体。
      5. HTTP响应
        - 服务器处理请求并返回HTTP响应，包含状态行、响应头和响应体。
        - 响应体包含实际的资源内容，如HTML文档、CSS样式表、JavaScript脚本等。
      6. 渲染页面
        - 浏览器解析HTML文档，构建DOM树；解析CSS样式表，构建CSSOM树；结合DOM树和CSSOM树，构建渲染树。
        - 浏览器进行布局计算，将渲染树中的元素转换为实际的像素位置和大小，并绘制到屏幕上。
    ## 断点续传
      1. 断点续传是指在下载或上传过程中，如果连接中断，可以从中断的地方继续传输，而不是从头开始。
      2. 实现断点续传通常需要服务器和客户端的支持，主要通过HTTP头部的Range字段来实现。
      3. 客户端在发送请求时，可以在请求头中添加Range字段，指定要下载的字节范围，如Range: bytes=1000-2000，表示从第1000个字节到第2000个字节。
      4. 服务器在响应中返回206 Partial Content状态码，并包含Content-Range头部，指示返回的字节范围和总大小。
      5. 如果服务器不支持断点续传，则会返回200 OK状态码，并返回整个资源内容。
      6. 断点续传可以提高下载效率，减少网络带宽消耗，特别适用于大文件下载或上传场景。
      7. 在实现断点续传时，需要注意处理文件的完整性和一致性，确保在恢复下载时不会出现数据损坏或丢失的情况。
    ## 网络性能优化
      1. 优化打包体积
      2. 压缩资源
        - 使用Gzip或Brotli等压缩算法对静态资源进行压缩，减少传输数据量。
        - 在服务器配置中启用压缩功能，设置正确的Content-Encoding头部。
      3. 使用CDN
        - 使用内容分发网络（CDN）将静态资源分发到离用户更近的节点，减少延迟和加载时间。
        - CDN可以缓存静态资源，提高访问速度和可靠性。
      4. 减少HTTP请求
        - 合并CSS和JavaScript文件，减少请求数量。
        - 使用雪碧图（Sprite）将多个小图片合并为一张大图，减少图片请求数量。
        - 使用字体图标代替图片，减少图片请求。
  # 工程化
    ## 模块化
      1. 什么是模块化
        - 模块化是将代码分割成独立的、可重用的模块，以提高代码的组织性、可维护性和可扩展性。
        - 模块化可以帮助开发者更好地管理代码，避免命名冲突，提高代码复用率。
      2. 模块化的方式
        - CommonJS：Node.js使用的模块化规范，通过require()函数加载模块，使用module.exports导出模块。
        - AMD（Asynchronous Module Definition）：浏览器端的模块化规范，通过define()函数定义模块，使用require()函数加载模块。
        - ES6模块：JavaScript标准的模块化规范，通过import和export关键字定义和导入模块，支持静态分析和树摇优化。
        - UMD（Universal Module Definition）：兼容CommonJS、AMD和全局变量的模块化规范，适用于多种环境。
      3. 模块化的优势
        - 提高代码组织性：将相关功能封装在独立的模块中，便于管理和维护。
        - 避免命名冲突：每个模块都有自己的作用域，避免全局变量污染。
        - 提高代码复用率：可以在多个项目中复用相同的模块，减少重复代码。
        - 支持依赖管理：可以明确指定模块之间的依赖关系，方便加载和执行顺序控制。
    ## monorepo
      1. 什么是monorepo
        - Monorepo（单一代码仓库）是一种将多个相关项目或模块存储在同一个代码仓库中的管理方式。
        - Monorepo可以提高代码共享和协作效率，简化依赖管理和版本控制。
      2. Monorepo的优势
        - 统一管理：所有相关项目都在同一个仓库中，便于统一管理和维护。
        - 代码共享：可以轻松共享和复用代码，减少重复工作。
        - 简化依赖管理：可以使用统一的包管理工具来处理依赖关系，避免版本冲突。
        - 提高协作效率：团队成员可以更方便地协作和交流，共享相同的开发环境和工具链。
      3. Monorepo的挑战
        - 仓库规模：随着项目数量增加，仓库可能变得庞大，影响性能和加载速度。
        - 构建和测试：需要处理多个项目的构建和测试流程，可能需要额外的配置和工具支持。
        - 版本控制：需要处理多个项目的版本控制，可能会增加复杂性。
      4. Monorepo的工具
        - Lerna：一个用于管理Monorepo的工具，可以处理包的版本控制、依赖关系和发布流程。
        - Yarn Workspaces：Yarn的一个功能，可以在Monorepo中管理多个包，简化依赖安装和链接。
        - Nx：一个用于构建和管理Monorepo的工具，提供了强大的依赖分析、构建缓存和测试支持。
    ## 包管理工具
      1. 什么是包管理工具
        - 包管理工具是用于管理项目依赖库和工具的工具，可以自动下载、安装、更新和卸载依赖包。
        - 包管理工具可以简化依赖管理，提高开发效率，确保项目的一致性和可移植性。
      2. 常见的包管理工具
        - npm（Node Package Manager）：Node.js默认的包管理工具，用于安装和管理JavaScript包。
        - yarn：Facebook开发的包管理工具，提供更快的安装速度和更好的依赖解析能力。
        - pnpm：一个快速、节省磁盘空间的包管理工具，通过硬链接共享依赖库来减少重复安装。
      3. 使用包管理工具
        - 使用npm或yarn等包管理工具
      4. 发布npm包的流程
        - 在项目根目录下创建package.json文件，定义包的名称、版本、描述、入口文件等信息。
        - 编写代码并测试，确保包的功能正常。
        - 使用npm login命令登录到npm账户。
        - 使用npm publish命令将包发布到npm仓库。
        - 发布后，可以使用npm install命令在其他项目中安装该包。
    ## 构建工具
      1. 什么是构建工具
        - 构建工具是用于自动化处理项目构建、打包、压缩、编译等任务的工具，可以提高开发效率和代码质量。
        - 构建工具可以处理JavaScript、CSS、图片等静态资源，生成最终的可部署代码。
      2. 常见的构建工具
        - Webpack：一个强大的模块打包工具，可以处理JavaScript、CSS、图片等资源，支持热更新和代码分割。
        - Rollup：一个用于打包JavaScript库的工具，支持ES6模块，生成更小的代码包。
        - Parcel：一个零配置的快速构建工具，支持热更新和自动安装依赖。
        - Gulp：一个基于流的自动化构建工具，可以处理文件操作、编译、压缩等任务。
      3. 使用构建工具
        - 使用Webpack或其他构建工具配置项目的打包和编译流程，处理静态资源，生成最终的可部署代码。
        - 配置热更新、代码分割、Tree Shaking等功能，提高开发效率和代码质量。
        - 使用插件和加载器扩展构建工具的功能，如处理CSS预处理器、图片压缩、代码压缩等。
    ## Eslint\commitLint
      1. 什么是Eslint
        - Eslint是一个用于检查JavaScript代码质量和风格的工具，可以帮助开发者发现和修复代码中的潜在问题。
        - Eslint可以配置规则，自动检测代码中的错误、不规范的写法，并提供修复建议。
      2. 使用Eslint
        - 在项目中安装Eslint依赖，并创建配置文件（如.eslintrc.js）来定义规则。
        - 可以使用Eslint命令行工具或集成到编辑器中进行实时检查和修复。
        - 可以使用插件扩展Eslint的功能，如支持React、Vue等框架的特定规则。
        - 常见的Eslint规则包括：
          - no-unused-vars：禁止未使用的变量。
          - eqeqeq：要求使用严格相等运算符（===）而不是宽松相等运算符（==）。
          - semi：要求使用分号结尾。
          - quotes：要求使用单引号或双引号。
      3. 什么是commitLint
        - commitLint是一个用于检查Git提交信息格式的工具，可以确保提交信息符合团队约定的规范。
        - commitLint可以配置规则，自动检测提交信息是否符合规范，并提供提示信息。
      4. 使用commitLint
        - 在项目中安装commitLint依赖，并创建配置文件（如.commitlintrc.js）来定义规则。
        - 可以在Git钩子中集成commitLint，在提交时自动检查提交信息格式。
        - 可以使用插件扩展commitLint的功能，如支持自定义规则、集成到CI/CD流程等。
        - 常见规范
包括：
          - type：提交类型，如feat（新功能）、fix（修复bug）、docs（文档变更）等。
          - scope：提交范围，如组件名、模块名等。
          - subject：简短的提交描述，通常不超过50个字符。
          - body：详细的提交说明，可选部分。
          - footer：用于关联问题或任务编号，可选部分。
  # React
    ## React的生命周期
      1. 生命周期概述
        - React组件的生命周期分为三个主要阶段：挂载（Mounting）、更新（Updating）和卸载（Unmounting）。
        - 每个阶段都有一系列生命周期方法，可以在这些方法中执行特定的操作，如数据获取、DOM操作等。
      2. 挂载阶段
        - constructor：组件实例化时调用，用于初始化状态和绑定事件处理函数。
        - static getDerivedStateFromProps：在渲染前调用，根据props更新state，适用于无副作用的场景。
        - render：渲染组件，返回React元素。
        - componentDidMount：组件挂载后调用，适用于数据获取、订阅等副作用操作。
      3. 更新阶段
        - static getDerivedStateFromProps：在更新前调用，根据新的props更新state。
        - shouldComponentUpdate：决定组件是否需要重新渲染，返回true或false。
        - render：重新渲染组件，返回新的React元素。
        - getSnapshotBeforeUpdate：在DOM更新前调用，可以获取更新前的快照。
        - componentDidUpdate：组件更新后调用，适用于数据获取、订阅等副作用操作。
      4. 卸载阶段
        - componentWillUnmount：组件卸载前调用，用于清理订阅、取消定时器等操作。
      5. 错误处理
        - static getDerivedStateFromError：在子组件抛出错误时调用，用于更新state以显示错误边界。
        - componentDidCatch：捕获子组件的错误，并执行相应的错误处理逻辑。
    ## React Hooks
      1. 什么是Hooks
        - Hooks是React 16.8引入的一种新特性，用于在函数组件中使用状态和其他React特性，而无需编写类组件。
        - Hooks提供了一种更简洁和可读的方式来管理状态、副作用和上下文等功能。
      2. 常用Hooks
        - useState：用于在函数组件中添加状态管理功能，返回一个包含当前状态值和更新函数的数组。
          ```javascript
          const [count, setCount] = useState(0);
          ```
        - useEffect
          - 用于在函数组件中处理副作用，如数据获取、订阅、DOM操作等。可以指定依赖项数组来控制副作用的执行时机。
          ```javascript
          useEffect(() => {
            // 执行副作用操作
            return () => {
              // 清理副作用
            };
          }, [dependencies]); // 依赖项数组
          ```
        - useContext：用于在函数组件中访问React上下文，避免了使用Context.Consumer的嵌套。
          ```javascript
          const value = useContext(MyContext); // 获取上下文值
          ```
        - useReducer：用于在函数组件中管理复杂状态，类似于Redux的reducer模式，适用于需要多个状态更新逻辑的场景。
          ```javascript
          const [state, dispatch] = useReducer(reducer, initialState);
          ```
        - useRef：用于在函数组件中创建可变的引用，类似于类组件中的实例变量，可以用于访问DOM元素或存储任何可变数据。
          ```javascript
          const inputRef = useRef(null); // 创建引用
    
          useEffect(() => {
            inputRef.current.focus(); // 访问DOM元素
          }, []);
          ```
        - useMemo：用于在函数组件中缓存计算结果，避免不必要的重新计算，提高性能。
          ```javascript
          const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
          ```
        - useCallback：用于在函数组件中缓存函数，避免不必要的函数重新创建，提高性能。
          ```javascript
          const memoizedCallback = useCallback(() => {
            doSomething(a, b);
          }, [a, b]);
          ```
      3. 自定义Hooks
        - 可以创建自定义Hooks来封装逻辑和状态管理，以便在多个组件中复用。
        - 自定义Hooks的命名以use开头，内部可以使用其他Hooks。
          ```javascript
          function useCustomHook() {
            const [state, setState] = useState(initialState);
            // 其他逻辑
            return [state, setState];
          }
          ```
      4. 使用Hooks的注意事项
        - 只能在函数组件或自定义Hooks中调用，不能在类组件或普通函数中调用。
        - 只能在顶层调用，不能在条件语句、循环或嵌套函数中调用，以确保Hooks的调用顺序一致。
        - 可以使用useEffect来处理副作用，但需要注意清理副作用以避免内存泄漏。
        - 使用依赖项数组来控制副作用的执行时机，避免不必要的重新执行。
        - 使用useMemo和useCallback来优化性能，避免不必要的重新计算和函数创建。
      5. Hooks的优势
        - 更简洁的语法：Hooks使得函数组件可以使用状态和副作用，避免了类组件的复杂性。
        - 更好的可读性：Hooks使得逻辑更清晰，易于理解和维护。
        - 更好的复用性：可以创建自定义Hooks来封装逻辑，实现代码复用。
        - 更好的测试性：函数组件和Hooks更容易进行单元测试，减少了依赖于类组件的复杂性。
      6. Hooks的限制
        - 只能在函数组件或自定义Hooks中使用，不能在类组件或普通函数中使用。
        - 只能在顶层调用，不能在条件语句、循环或嵌套函数中调用，以确保Hooks的调用顺序一致。
        - 需要遵循Hooks的规则，如只能在React函数组件或自定义Hooks中调用，不能在条件语句、循环或嵌套函数中调用。
        - 不能在类组件中使用Hooks，类组件需要使用生命周期方法来处理状态和副作用。
      7. useCallback和useMemo的区别
        - useCallback用于缓存函数，避免不必要的函数重新创建，适用于传递给子组件的回调函数。
          ```javascript
          const memoizedCallback = useCallback(() => {
            doSomething(a, b);
          }, [a, b]);
          ```
        - useMemo用于缓存计算结果，避免不必要的重新计算，适用于计算开销较大的值。
          ```javascript
          const memoizedValue = useMemo(() => computeExpensi veValue(a, b), [a, b]);
          ```
        - useCallback返回的是一个函数，而useMemo返回的是一个值。
        - 调用阶段：useCallback在每次渲染时都会返回一个新的函数，而useMemo在依赖项未变化时会返回缓存的值。
    ## diff
      1. 什么是Diff算法
        - Diff算法是React用于高效更新虚拟DOM的算法，通过比较新旧虚拟DOM树的差异，最小化实际DOM操作，提高渲染性能。
        - React使用O(n)的时间复杂度来比较两个虚拟DOM树，避免了O(n^3)的暴力比较。
      2. Diff算法的核心思想
        - 通过将虚拟DOM树分为多个层次和节点，逐层比较新旧节点的差异，找到需要更新的部分。
        - 使用唯一标识符（key）来优化节点的比较和重用，减少不必要的DOM操作。
        - 只对同一层级的节点进行比较，不跨层级比较，以提高性能。
      3. Diff算法的实现步骤
        - 比较两个虚拟DOM树的根节点，如果根节点不同，则替换整个子树。
        - 对于相同类型的节点，比较其属性和子节点，更新属性并递归比较子节点。
        - 对于不同类型的节点，直接替换整个子树。
        - 使用key来优化列表渲染，减少不必要的重绘和重排。
      4. Diff算法的优化
        - 使用唯一标识符（key）来优化列表渲染，提高节点复用率。
        - 避免在同一层级中频繁插入、删除或移动节点，以减少Diff计算量。
        - 使用shouldComponentUpdate或React.memo来控制组件更新，避免不必要的渲染。
      4. react的diff算法
        - React的Diff算法是基于虚拟DOM的，通过比较新旧虚拟DOM树的差异，最小化实际DOM操作，提高渲染性能。
        - React使用O(n)的时间复杂度来比较两个虚拟DOM树，避免了O(n^3)的暴力比较。
        - React的Diff算法分为以下几个步骤：
          1. 比较根节点，如果根节点不同，则替换整个子树。
          2. 对于相同类型的节点，比较其属性和子节点，更新属性并递归比较子节点。
          3. 对于不同类型的节点，直接替换整个子树。
          4. 使用key来优化列表渲染，减少不必要的重绘和重排。
        - React还提供了shouldComponentUpdate和React.memo等机制来控制组件更新，避免不必要的渲染。
    ## fiber
      1. 什么是Fiber
        - Fiber是React 16引入的全新协调算法，用于替代旧版的Reconciler算法，旨在提高React的渲染性能和响应性。
        - Fiber将组件树分为多个单元（Fiber节点），每个Fiber节点代表一个组件实例，包含组件的状态、属性和子节点等信息。
      2. Fiber的核心概念
        - Fiber节点：每个组件实例对应一个Fiber节点，包含组件的状态、属性、子节点等信息。
        - 工作单元：Fiber节点可以被划分为多个工作单元，允许React在渲染过程中进行中断和恢复，提高响应性。
        - 调度器：Fiber使用调度器来管理工作单元的执行顺序，可以根据优先级动态调整渲染任务。
      3. Fiber的优势
        - 增量渲染：Fiber允许React在渲染过程中进行中断和恢复，可以在空闲时间继续渲染，提高响应性。
        - 优先级调度：Fiber可以根据任务的优先级动态调整渲染顺序，确保高优先级任务优先执行。
        - 更好的错误处理：Fiber提供了更好的错误处理机制，可以捕获和处理渲染过程中的错误。
      4. Fiber的实现原理
        - Fiber使用双向链表来表示组件树，每个Fiber节点包含指向父节点、子节点和兄弟节点的引用。
        - 在渲染过程中，React会遍历Fiber树，比较新旧Fiber节点的差异，并更新实际DOM。
        - Fiber支持增量渲染，可以在渲染过程中进行中断和恢复，提高响应性。
        - Fiber使用调度器来管理工作单元的执行顺序，可以根据优先级动态调整渲染任务。
  # Typescript
    ## TypeScript概述
      1. 什么是TypeScript
        - TypeScript是JavaScript的超集，添加了静态类型检查和其他特性，旨在提高代码的可维护性和可读性。
        - TypeScript编译器会将TypeScript代码转换为标准的JavaScript代码，可以在任何支持JavaScript的环境中运行。
      2. TypeScript的优势
        - 静态类型检查：TypeScript提供了强大的类型系统，可以在编译时捕获类型错误，提高代码质量。
        - 更好的IDE支持：TypeScript提供了更好的代码补全、重构和导航功能，提高开发效率。
        - 支持最新的JavaScript特性：TypeScript支持最新的JavaScript语法和特性，如ES6模块、箭头函数等。
        - 更好的文档生成：TypeScript可以生成更好的文档，便于团队协作和代码维护。
      3. TypeScript的基本语法
        - 类型注解：可以为变量、函数参数和返回值添加类型注解，如`let count: number = 0;`。
        - 接口（Interface）：定义对象的结构和类型，如`interface User { name: string; age: number; }`。
        - 类（Class）：使用类来定义对象的行为和属性，如`class Person { constructor(public name: string, public age: number) {} }`。
        - 泛型（Generics）：使用泛型来定义可重用的类型，如`function identity<T>(arg: T): T { return arg; }`。
      4. TypeScript配置
        - 使用tsconfig.json文件来配置TypeScript编译选项，如目标版本、模块系统、类型检查等。
        - 可以使用命令行工具或构建工具（如Webpack）来编译TypeScript代码。
      5. TypeScript与JavaScript的关系
        - TypeScript是JavaScript的超集，所有有效的JavaScript代码都是有效的TypeScript代码。
        - TypeScript添加了类型系统和其他特性，但仍然可以使用JavaScript的语法和特性。
        - TypeScript编译器会将TypeScript代码转换为标准的JavaScript代码，可以在任何支持JavaScript的环境中运行。
    ## 常用类型
      1. 基本类型
        - number：表示数字类型，如整数和浮点数。
        - string：表示字符串类型。
        - boolean：表示布尔类型，true或false。
        - null：表示空值。
        - undefined：表示未定义的值。
        - any：表示任意类型，可以赋值为任何类型，但会失去类型检查的优势。
      2. 数组和元组
        - 数组：使用`number[]`或`Array<number>`表示数字数组，使用`string[]`或`Array<string>`表示字符串数组等。
          ```typescript
          let numbers: number[] = [1, 2, 3];
          let strings: Array<string> = ['a', 'b', 'c'];
          ```
        - 元组：使用元组类型来表示固定长度和类型的数组，如`[string, number]`表示一个包含字符串和数字的元组。
          ```typescript
          let tuple: [string, number] = ['Alice', 30];
          ```
      3. 对象和接口
        - 对象：使用对象字面量或接口来定义对象的结构和类型，如`{ name: string; age: number; }`。
          ```typescript
          let user: { name: string; age: number } = { name: 'Alice', age: 30 };
          ```
        - 接口：使用接口来定义对象的结构，可以复用和扩展接口，如`interface User { name: string; age: number; }`。
          ```typescript
          interface User {
            name: string;
            age: number;
          }
          let user: User = { name: 'Alice', age: 30 };
          ```
      4. 函数类型
        - 使用函数类型注解来定义函数的参数和返回值类型，如`(x: number, y: number) => number`表示一个接受两个数字参数并返回一个数字的函数。
          ```typescript
          function add(x: number, y: number): number {
            return x + y;
          }
          ```
      5. 联合类型和交叉类型
        - 联合类型（Union Type）：使用竖线（|）来表示可以是多种类型中的一种，如`string | number`
          ```typescript
          let value: string | number = 'Hello';
          value = 42; // 也可以是数字
          ```
        - 交叉类型（Intersection Type）：使用&符号来表示多个类型的组合，如`{ name: string } & { age: number }`表示一个同时具有name和age属性的对象。
          ```typescript
          interface Name {
            name: string;
          }
          interface Age {
            age: number;
          }
          type Person = Name & Age; // 交叉类型
          let person: Person = { name: 'Alice', age: 30 };
          ```
      6. 枚举类型
        - 使用枚举类型来定义一组命名的常量，如`enum Color { Red, Green, Blue }`。
          ```typescript
          enum Color {
            Red,
            Green,
            Blue
          }
          let color: Color = Color.Red; // 使用枚举值
          ```
    ## ts常用内置类型
      1. Partial<T>
        - 将类型T的所有属性变为可选属性，适用于需要部分更新对象的场景。
        ```typescript
        interface User {
          name: string;
          age: number;
        }
        let partialUser: Partial<User> = { name: 'Alice' }; // age属性是可选的
        ```
      2. Required<T>
        - 将类型T的所有属性变为必需属性，适用于需要确保所有属性都存在的场景。
        ```typescript
        interface User {
          name?: string;
          age?: number;
        }
        let requiredUser: Required<User> = { name: 'Alice', age: 30 }; // 所有属性都是必需的
        ```
      3. Readonly<T>
        - 将类型T的所有属性变为只读属性，适用于需要防止修改对象的场景。
        ```typescript
        interface User {
          name: string;
          age: number;
        }
        let readonlyUser: Readonly<User> = { name: 'Alice', age: 30 };
        // readonlyUser.name = 'Bob'; // 错误：不能修改只读属性
        ```
      4. Record<K, T>
        - 创建一个对象类型，其键为K，值为T，适用于需要创建键值对映射的场景。
        ```typescript
        type UserRoles = Record<string, string>; // 键为字符串，值为字符串
        let roles: UserRoles = { admin: 'Administrator', user: 'Regular User' };
        ```
      5. Pick<T, K>
        - 从类型T中选择一部分属性K，创建一个新类型，适用于需要从现有类型中提取部分属性的场景。
        ```typescript
        interface User {
          name: string;
          age: number;
          email: string;
        }
        type UserNameAndEmail = Pick<User, 'name' | 'email'>; // 只选择name和email属性
        let user: UserNameAndEmail = { name: 'Alice', email: 'alice@example.com' };
        ```
      6. Omit<T, K>
        - 从类型T中排除一部分属性K，创建一个新类型，适用于需要从现有类型中排除某些属性的场景。
        ```typescript
        interface User {
          name: string;
          age: number;
          email: string;
        }
        type UserWithoutEmail = Omit<User, 'email'>; // 排除email属性
        let user: UserWithoutEmail = { name: 'Alice', age: 30 };
        ```
      7. Exclude<T, U>
        - 从类型T中排除类型U，创建一个新类型，适用于需要从联合类型中排除某些类型的场景。
        ```typescript
        type UnionType = string | number | boolean;
        type ExcludedType = Exclude<UnionType, number>; // 排除number类型
        let value: ExcludedType = 'Hello'; // 只能是string或boolean
        ```
      8. Extract<T, U>
        - 从类型T中提取类型U，创建一个新类型，适用于需要从联合类型中提取某些类型的场景。
        ```typescript
        type UnionType = string | number | boolean;
        type ExtractedType = Extract<UnionType, string | number>; // 提取string和number类型
        let value: ExtractedType = 42; // 可以是string或number
        ```
      9. NonNullable<T>
        - 从类型T中排除null和undefined，创建一个新类型，适用于需要确保值不为null或undefined的场景。
        ```typescript
        type NullableType = string | null | undefined;
        type NonNullableType = NonNullable<NullableType>; // 排除null和undefined
        let value: NonNullableType = 'Hello'; // 只能是string
        ```
