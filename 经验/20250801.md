# 2025年8月1日面试记录

## JavaScript 基础

### 1. try catch 无法捕获 Promise 异常的原因

**核心原因：** 异步执行的时序问题

当 Promise 发生异常时，异常是在异步回调中抛出的，而此时 try catch 的执行上下文已经结束了。

**错误示例：**
```javascript
// ❌ 无法捕获
try {
  const promise = new Promise((resolve, reject) => {
    setTimeout(() => {
      throw new Error('异步错误'); // 这个错误无法被捕获
    }, 1000);
  });
} catch (error) {
  console.log('捕获到错误:', error); // 不会执行
}

// ❌ 同样无法捕获
try {
  fetch('/api/data'); // Promise 内部的网络错误无法被捕获
} catch (error) {
  console.log('捕获到错误:', error); // 不会执行
}
```

**正确处理方式：**
```javascript
// 1. 使用 .catch() 方法
promise
  .then(result => {
    // 处理成功结果
  })
  .catch(error => {
    console.log('捕获到错误:', error);
  });

// 2. 使用 async/await + try catch
async function handlePromise() {
  try {
    const result = await promise;
    // 处理结果
  } catch (error) {
    console.log('捕获到错误:', error);
  }
}

// 3. 处理 unhandledRejection（Node.js）
process.on('unhandledRejection', (reason, promise) => {
  console.log('未处理的 Promise 拒绝:', reason);
});
```

### 2. try catch 是同步任务还是异步任务

**答案：** try catch 本身是同步任务

**特点：**
- 语句本身同步执行
- 只能捕获同步异常
- 无法捕获异步异常

```javascript
// 执行栈示例
try {          // 执行栈 A
  setTimeout(() => {  // 回调在执行栈 B 中执行
    throw new Error(); // 执行栈 B 的异常
  }, 0);
} catch (error) {    // 执行栈 A 无法捕获执行栈 B 的异常
  // 不会执行
}
```

### 3. 遍历对象的方法

| 方法 | 特点 | 用途 |
|------|------|------|
| `for...in` | 遍历所有可枚举属性（包括继承的） | 需要遍历继承属性时 |
| `Object.keys()` | 只返回自有的可枚举属性键 | 最常用，安全可靠 |
| `Object.values()` | 只返回自有的可枚举属性值 | 只需要值时 |
| `Object.entries()` | 返回 [key, value] 数组对 | 需要同时访问键值对 |
| `Object.getOwnPropertyNames()` | 包括不可枚举的自有属性 | 需要所有自有属性时 |
| `Reflect.ownKeys()` | 包括字符串键和 Symbol 键 | 需要完整的属性列表时 |

```javascript
const obj = { a: 1, b: 2, c: 3 };

// 推荐使用
Object.keys(obj).forEach(key => {
  console.log(key, obj[key]);
});

// 或者
for (const [key, value] of Object.entries(obj)) {
  console.log(key, value);
}
```

### 4. for...in 遍历原型链

**答案：** 是的，for...in 可以遍历到原型链上的可枚举属性

```javascript
// 创建原型对象
const proto = {
  protoProperty: 'from prototype',
  protoMethod: function() { return 'prototype method'; }
};

// 创建对象，设置原型
const obj = Object.create(proto);
obj.ownProperty = 'own property';

// for...in 会遍历原型链
for (const key in obj) {
  if (obj.hasOwnProperty(key)) {
    console.log('自有属性:', key, obj[key]);
  } else {
    console.log('继承属性:', key, obj[key]);
  }
}
```

**最佳实践：**
```javascript
// ✅ 推荐 - 使用 Object.keys()
Object.keys(obj).forEach(key => {
  // 只处理自有属性
});

// ✅ 推荐 - 明确只要自有属性
for (const key in obj) {
  if (obj.hasOwnProperty(key)) {
    // 处理自有属性
  }
}
```

### 5. new 操作符的内部过程

**四个关键步骤：**

1. **创建新的空对象**
2. **设置原型链**：将新对象的 `__proto__` 指向构造函数的 `prototype`
3. **绑定 this 并执行构造函数**
4. **返回对象**：如果构造函数返回对象则返回该对象，否则返回新创建的对象

```javascript
// 手动实现 new 操作符
function myNew(Constructor, ...args) {
  // 1. 创建新对象
  const newObj = {};
  
  // 2. 设置原型链
  Object.setPrototypeOf(newObj, Constructor.prototype);
  
  // 3. 绑定 this 并执行构造函数
  const result = Constructor.apply(newObj, args);
  
  // 4. 返回对象
  return (typeof result === 'object' && result !== null) ? result : newObj;
}
```

## CSS 相关

### 6. flex: 1 的含义

`flex: 1` 等价于：
```css
flex-grow: 1;    /* 扩展因子 */
flex-shrink: 1;  /* 收缩因子 */
flex-basis: 0%;  /* 基础大小 */
```

**实际效果：** 元素会占据剩余空间，如果有多个 `flex: 1` 的项目，会平均分配剩余空间。

### 7. flex 布局中左侧固定被挤压的问题

**问题原因：** `flex-shrink` 的默认行为导致固定宽度元素被压缩

**解决方案：**
```css
.left {
  width: 200px;
  flex-shrink: 0; /* 关键：禁止收缩 */
}

/* 或者使用 flex 简写 */
.left {
  flex: 0 0 200px; /* grow=0, shrink=0, basis=200px */
}

.right {
  flex: 1; /* 占据剩余空间 */
}
```

### 8. CSS 盒模型分类和区别

**两种盒模型：**

1. **标准盒模型（W3C 盒模型）**
```css
box-sizing: content-box; /* 默认值 */
```
- `width/height` 只包含 content
- 元素总宽度 = width + padding + border + margin

2. **IE 盒模型（怪异盒模型）**
```css
box-sizing: border-box;
```
- `width/height` 包含 content + padding + border
- 元素总宽度 = width + margin

**推荐全局设置：**
```css
*, *::before, *::after {
  box-sizing: border-box;
}
```

### 9. 绝对定位的参考对象和定位点

**参考对象：** 最近的非 `static` 定位的祖先元素，如果找不到则相对于初始包含块（html元素）

**定位点：** 参考元素的 content box（内容区域）边界，即 padding 的内边缘

```css
.parent {
  position: relative;
  padding: 30px;
  border: 10px solid blue;
}

.child {
  position: absolute;
  top: 0;    /* 相对于 padding 内边缘，不是 border 外边缘 */
  left: 0;
}
```

### 10. 重排和重绘相关的属性

**触发重排的属性：**
- `offsetWidth` ✅ 重排
- `clientWidth` ✅ 重排  
- `scrollWidth` ✅ 重排

**不触发重排重绘的属性：**
- `screen.width` ❌ 既不重排也不重绘

**不会引起重排或重绘的修改：**
```javascript
// ✅ 只触发合成，不重排不重绘
element.style.transform = 'translateX(100px)';
element.style.opacity = '0.5';
element.style.filter = 'blur(5px)';
```

### 11. 浏览器渲染机制

**渲染不是 JavaScript 任务**，它是浏览器的原生渲染机制，不属于微任务或宏任务。

**事件循环的完整流程：**
1. 执行一个宏任务
2. 执行所有微任务
3. 检查是否需要渲染
4. 执行渲染（如果需要）
5. 进入下一轮循环

### 12. requestAnimationFrame 的任务类型

**答案：** 既不是宏任务也不是微任务，它有自己独立的任务队列

**执行时机：**
1. 执行一个宏任务
2. 执行所有微任务
3. 检查是否需要渲染
4. **执行 requestAnimationFrame 回调** ← 这里
5. 执行渲染
6. 进入下一轮循环

```javascript
// 执行顺序验证
console.log('1: 同步');
setTimeout(() => console.log('4: 宏任务'), 0);
Promise.resolve().then(() => console.log('2: 微任务'));
requestAnimationFrame(() => console.log('3: rAF'));

// 输出: 1: 同步 → 2: 微任务 → 3: rAF → 4: 宏任务
```

### 13. CSS 分层机制的区别

| 属性 | 作用范围 | 影响对象 | 层叠规则 |
|------|----------|----------|----------|
| `z-index` | 定位元素间 | 整个元素 | 数值大的在上 |
| `overflow` | 元素内部 | 子元素显示 | 创建裁剪区域 |
| `background` | 元素背景 | 背景图层 | 后声明的在上 |

**CSS 渲染层次（从下到上）：**
1. 根元素背景
2. 负 z-index 的定位元素
3. 非定位块级元素
4. 非定位浮动元素
5. 非定位行内元素
6. z-index: 0 的定位元素
7. 正 z-index 的定位元素

## React 相关

### 14. useLayoutEffect vs useEffect

**核心区别：** 执行时机不同

| 特性 | useEffect | useLayoutEffect |
|------|-----------|-----------------|
| 执行时机 | 重绘后异步执行 | 重绘前同步执行 |
| 阻塞渲染 | 不阻塞 | 阻塞渲染 |
| 适用场景 | 副作用、异步操作 | DOM 测量、防止闪烁 |
| 性能影响 | 较小 | 可能较大 |

**React 渲染流程：**
```
渲染阶段 → useLayoutEffect → 浏览器重绘 → useEffect
```

**使用场景：**
```javascript
// ✅ 适合使用 useLayoutEffect
function Tooltip() {
  const [position, setPosition] = useState({ x: 0, y: 0 });
  
  useLayoutEffect(() => {
    // 在重绘前设置位置，避免闪烁
    const rect = element.getBoundingClientRect();
    setPosition({ x: rect.left, y: rect.top });
  });
}

// ✅ 适合使用 useEffect
function DataComponent() {
  useEffect(() => {
    // 异步操作使用 useEffect
    fetch('/api/data').then(setData);
  }, []);
}
```

## 虚拟滚动

### 15. 虚拟滚动原理

**核心思想：** 只渲染用户可见区域的内容，通过动态计算和DOM复用来处理大量数据

**关键计算：**
```javascript
const itemHeight = 50;
const containerHeight = 500;
const totalItems = 10000;

// 可见数量
const visibleCount = Math.ceil(containerHeight / itemHeight);

// 起始索引
const startIndex = Math.floor(scrollTop / itemHeight);

// 渲染范围
const endIndex = startIndex + visibleCount;
```

**动画处理：**
```javascript
// 使用 transform 而不是 top
function renderItem(index) {
  const element = getItemElement(index);
  const translateY = index * itemHeight;
  
  // ✅ 性能更好
  element.style.transform = `translateY(${translateY}px)`;
  element.style.willChange = 'transform';
}
```

## Webpack

### 16. Plugin vs Loader 的区别

| 维度 | Loader | Plugin |
|------|--------|--------|
| 主要作用 | 转换文件内容 | 扩展构建功能 |
| 作用范围 | 单个文件 | 整个构建过程 |
| 工作时机 | 模块解析时 | 构建生命周期各阶段 |
| 配置位置 | `module.rules` | `plugins` 数组 |
| 实现方式 | 函数 | 包含 apply 方法的对象/类 |

**Loader 示例：**
```javascript
// 文件转换
{
  test: /\.scss$/,
  use: [
    'style-loader',    // 将 CSS 注入到 DOM
    'css-loader',      // 解析 CSS 文件
    'sass-loader'      // 编译 Sass 到 CSS
  ]
}
```

**Plugin 示例：**
```javascript
plugins: [
  new HtmlWebpackPlugin({
    template: './src/index.html'
  }),
  new MiniCssExtractPlugin({
    filename: '[name].[contenthash].css'
  })
]
```

**记忆口诀：**
- **Loader**：让 webpack 能够处理各种文件类型
- **Plugin**：让 webpack 具备各种强大功能

---

## 总结

这次面试涵盖了前端开发的核心知识点：
- JavaScript 异步编程和对象操作
- CSS 布局和渲染机制
- React Hooks 的深度理解
- 性能优化技术（虚拟滚动）
- 构建工具的工作原理

重点关注异步编程、CSS 渲染机制和性能优化相关的问题。